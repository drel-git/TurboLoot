| _______ _    _ _____  ____   ____  _      ____   ____ _______ 
| __   __| |  | |  __ \|  _ \ / __ \| |    / __ \ / __ \__   __|
|   | |  | |  | | |__) | |_) | |  | | |   | |  | | |  | | | |   
|   | |  | |  | |  _  /|  _ <| |  | | |   | |  | | |  | | | |   
|   | |  | |__| | | \ \| |_) | |__| | |___| |__| | |__| | | |   
|   |_|   \____/|_|  \_\____/ \____/|______\____/ \____/  |_|
|------------------------------------------------------------------>

| turboLoot 3.7.4
| Made by: <Lederhosen>, Drel, Jabs, Matde, Belakk, Veldrinn, Zhugg, Kroaking, Jeremy
| lootTribMinValue: unlisted items with tribute/value >= threshold looted as TRIBUTE

#turbo 100
#event Unlootable "You may not loot this corpse at this time."
#event TooFar "You are too far away to loot that corpse."
#event CursorOccupied "You may not loot an item while you have an item on your cursor."
|| Lazarus/RoF2 duplicate LORE denial (allow trailing punctuation/extra text)
#event LoreAlreadyPossess "You cannot pick up #1# because it is a lore item you already possess#*#"
|| Common alternate LORE denial (no item name in message)
#event LoreAlreadyPossessNoName "You already possess that item#*#"
|| P99-style duplicate LORE denial (no item name in message)
#event LoreAlreadyHaveOne "You cannot loot this Lore Item. You already have one#*#"
|| Exact-match variant (some clients/servers don't append extra characters)
#event LoreAlreadyHaveOneExact "You cannot loot this Lore Item. You already have one."
|| Generic catch-all for lore loot denial (covers punctuation/extra suffix text)
#event LoreDeniedGeneric "You cannot loot this Lore Item#*#"

| ---------------------------------------------------------------------
| MAIN
| ---------------------------------------------------------------------
Sub Main
    /declare mode string local ${Param0.Upper}
    | Check for dry-run flag (supports: dryrun, dry, preview, --dryrun)
    /declare dryRunParam string local ${Param1.Upper}
    /declare isDryRun bool local FALSE
    /if (${dryRunParam.Length} && (${dryRunParam.Equal[DRYRUN]} || ${dryRunParam.Equal[DRY]} || ${dryRunParam.Equal[PREVIEW]} || ${dryRunParam.Equal[--DRYRUN]})) {
        /varset isDryRun TRUE
    }
    
    | Reset any stale run flags from crashes
    /if (${Defined[turboLootRunning]}) /deletevar turboLootRunning
    /declare turboLootRunning bool global TRUE
    /if (${Defined[turboLootSafetyNet]}) /deletevar turboLootSafetyNet
    /declare turboLootSafetyNet int global 1

    | Help/commands (prints list and exits)
    /if (${mode.Equal[HELP]} || ${mode.Equal[COMMANDS]} || ${mode.Equal[CMDS]}) {
        /call PrintCommandsAndToggles
        /return
    }
    
    | Detect if user accidentally ran "/mac turboloot dryrun" instead of "/mac turboloot sell dryrun"
    /if (${mode.Equal[DRYRUN]} || ${mode.Equal[DRY]} || ${mode.Equal[PREVIEW]}) {
        /echo \at[turboLoot] \arERROR: Invalid command syntax!
        /echo \at[turboLoot] \ayYou ran: \aw/mac turboloot ${mode}
        /echo \at[turboLoot] \ayCorrect usage:
        /echo \at[turboLoot]   \ag/mac turboloot sell dryrun\aw - Preview what would be sold
        /echo \at[turboLoot] \ayAlternative syntax: \awdry\ay, \awpreview\ay, or \aw--dryrun\aw also work
        /return
    }

    | Route to sell mode if requested (minimal initialization for speed)
    /if (${mode.Equal[SELL]}) {
        /call InitStateMinimal
        /call LoadSettingsMinimal SELL
        /call PauseAFollow
        /declare dryRun bool outer ${isDryRun}
        /if (${isDryRun}) {
            /call AutoSellDryRun FALSE
        } else {
            /call AutoSell
            /if (${returnToLeader}) /call NavBackToGroupLeader
        }
        /call UnpauseAFollow
        /call Cleanup
        /return
    }

    | Route to report mode (alias for sell dryrun - preview what would be sold)
    /if (${mode.Equal[REPORT]}) {
        /call InitStateMinimal
        /call LoadSettingsMinimal SELL
        /declare dryRun bool outer TRUE
        /call AutoSellDryRun FALSE
        /call Cleanup
        /return
    }
    
    | Route to bank mode if requested (minimal initialization for speed)
    /if (${mode.Equal[BANK]}) {
        /call InitStateMinimal
        /call LoadSettingsMinimal BANK
        /call PauseAFollow
        /call AutoBank
        /if (${returnToLeader}) /call NavBackToGroupLeader
        /call UnpauseAFollow
        /call Cleanup
        /return
    }
    
    | Route to tribute mode if requested (minimal initialization for speed)
    /if (${mode.Equal[TRIBUTE]}) {
        /call InitStateMinimal
        /call LoadSettingsMinimal TRIBUTE
        /call PauseAFollow
        /call AutoTribute
        /if (${returnToLeader}) /call NavBackToGroupLeader
        /call UnpauseAFollow
        /call Cleanup
        /return
    }

    | Route to destroy mode if requested (minimal initialization for speed)
    | Destroy scans your inventory and /destroy's any items marked DESTROY in [ItemLimits]
    /if (${mode.Equal[DESTROY]}) {
        /call InitStateMinimal
        /call LoadSettingsMinimal DESTROY
        /call AutoDestroy
        /call Cleanup
        /return
    }

    | Route to unload mode if requested (minimal initialization for speed)
    | Unload runs: TRIBUTE -> BANK -> SELL -> DESTROY
    /if (${mode.Equal[UNLOAD]}) {
        /call InitStateMinimal
        /call LoadSettingsMinimal TRIBUTE
        /declare unloadReturn bool local ${returnToLeader}
        /call PauseAFollow
        /call AutoTribute
        /call LoadSettingsMinimal BANK
        /call AutoBank
        /call LoadSettingsMinimal SELL
        /call AutoSell
        /call AutoDestroy
        /call PrintUnloadSummary
        /if (${unloadReturn}) /call NavBackToGroupLeader
        /call UnpauseAFollow
        /call Cleanup
        /return
    }

    | Full initialization for normal looting mode
    /call InitState
    /call LoadSettings

    | Check for aggressive mobs if StopLootWhenAttacked is enabled
    /if (${stopLootWhenAttacked}) {
        /if (${SpawnCount[npc radius ${lootDistance} los playerstate 4]}) {
            /echo ${tlTag} \arWARNING: STOPPING turboLoot - Aggressive mobs detected in loot area!
            /call Cleanup
            /return
        }
    }

    /call PreChecks
    /if (!${turboLootRunning}) /return

    /call PauseE3Logic

    /if (!${turboLootRunning}) /return

    /call BeginLooting

    /call PrintSummary
    /call Cleanup
/return

| ---------------------------------------------------------------------
| INIT STATE
| ---------------------------------------------------------------------
Sub InitState
    | Core state / bookkeeping (outer scope so helpers can see them)
    /declare AlertIndex int outer 1
    /if (${AlertIndex}) /squelch /alert clear ${AlertIndex}

    /declare Skip bool outer FALSE
    /declare LoreBlocked bool outer FALSE
    /declare LoreBlockedName string outer ""
    | Track last lore-attempted item name (used for generic lore denial messages with no item name)
    /declare LoreAttemptName string outer ""
    | Cache lore-denied item names this session to avoid repeated "try -> deny" loops (bank-count bug workaround)
    | Stored as a delimiter-wrapped string: |Name1||Name2|
    /declare LoreDeniedNames string outer ""
    | Per-corpse /gsay dedupe for [SKIP] spam (keyed by corpse ID + loot slot + item name)
    /declare SkipGsayKeys string outer ""
    /declare DidLoot bool outer FALSE
    /declare DidLootThisCorpse bool outer FALSE
    | Message prefix for consistent colored MQ output (works for /echo and /e3bc)
    /declare tlTag string outer \at[turboLoot]
    /declare abortingMacro bool outer FALSE

    /declare showDebug bool outer
    /declare enableHighValue int outer
    /declare minLootValue int outer
    /declare lootHighValueAll bool outer FALSE
    /declare minStackableValue int outer
    /declare lootStackable bool outer
    /declare announceSkipped int outer 1
    /declare announceLooted bool outer
    /declare announceMethod string outer
    /declare announceLore bool outer
    /declare announceLoreMethod string outer
    /declare announceSkippedMethod string outer
    /if (!${Defined[announceBankSell]}) /declare announceBankSell string outer
    /declare announceBankSellProgress int outer 0
    /declare announceBankSellPerItem int outer 1
    /declare announceDestroyed bool outer
    /declare announceSummary int outer
    /declare announceSummaryMethod string outer
    /declare announceDefaultTo string outer "echo"
    /declare restoreFollowMode string outer
    /declare restoreFollowDriver string outer
    /declare afollowWasPaused bool outer FALSE
    | StopLootWhenAttacked: if enabled, stops looting when aggressive mobs are in loot area
    /declare stopLootWhenAttacked bool outer FALSE
    | AutoRsayInRaid: if enabled, auto-switches announce method to rsay when in a raid
    /declare autoRsayInRaid bool outer FALSE
    | Check if iniFile global already exists and delete it before redeclaring
    /if (${Defined[iniFile]}) /deletevar iniFile
    /declare iniFile string global
    /declare MaxLootRetries int outer 10
    /declare lootDistance int outer
    /declare finalSweepEnabled int outer 1
    /declare finalSweepRadiusFeet int outer 0
    /declare mainLoopIterations int outer 0
    /declare maxMainLoopIterations int outer 5000
    /declare corpseID int outer 0

    | Scratch variables used in main loop
    /declare loottotal int outer
    /declare lootslot int outer
    /declare lootName string outer
    /declare itemValue int outer
    /declare tribVal int outer 0
    /declare lootNoDropPrompt string outer
    /declare lootNoDropPromptReset string outer

    | Variables used in BeginLooting (prevent redeclaration errors)
    /declare moveTries int outer 0
    /declare modeCheck string outer
    /declare itemLimit string outer
    /declare itemLimitUpper string outer
    /declare closeTries int outer 0
    /declare currentCount int outer 0
    /declare meetsTribThreshold bool outer FALSE

    | Variables for sell functionality (prevent redeclaration errors)
    /declare itemsSold int outer 0
    /declare platinumGain int outer 0
    /declare sellTotalCopper int outer 0
    /declare enableSellStackable bool outer
    /declare minSellStackableValue int outer
    /declare enableSellUnlistedValue bool outer
    /declare minSellUnlistedValue int outer
    /declare sellWildcards bool outer FALSE
    /declare bankWildcards bool outer FALSE
    /declare wildcardPrefixes string outer ""
    /declare packNum int outer 0
    /declare slotNum int outer 0
    /declare maxSlots int outer 0
    /declare itemID int outer 0
    /declare itemName string outer
    /declare tributeItemsMoved int outer 0
    /declare tributePointsGained int outer 0
    
    | Variables for bank functionality (prevent redeclaration errors)
    /declare itemsBanked int outer 0

    | Telemetry counters
    /declare itemsLooted int outer 0
    /declare itemsDestroyed int outer 0
    /declare itemsSkipped int outer 0
    /declare itemsIgnored int outer 0
    /declare corpsesProcessed int outer 0
    /declare announceInventoryAlmostFull int outer
    | Per-run warning dedupe for container autobank errors (keyed by container name)
    /declare BankContainerWarnedKeys string outer ""
    /declare lootTribMinValue int outer 0
/return

|| ---------------------------------------------------------------------
|| INIT STATE MINIMAL (for BANK/SELL modes - faster startup)
|| ---------------------------------------------------------------------
Sub InitStateMinimal
    | Only declare variables needed for banking/selling (skip looting-specific vars)
    /declare showDebug bool outer
    /declare announceLooted bool outer
    | Check if iniFile global already exists and delete it before redeclaring
    /if (${Defined[iniFile]}) /deletevar iniFile
    /declare iniFile string global
    /declare restoreFollowMode string outer
    /declare restoreFollowDriver string outer
    /declare afollowWasPaused bool outer FALSE
    /declare modeCheck string outer
    /declare itemsSold int outer 0
    /if (!${Defined[announceBankSell]}) /declare announceBankSell string outer
    /declare announceBankSellProgress int outer 0
    /declare announceBankSellPerItem int outer 1
    /declare platinumGain int outer 0
    /declare sellTotalCopper int outer 0
    /declare enableSellStackable bool outer
    /declare minSellStackableValue int outer
    /declare enableSellUnlistedValue bool outer
    /declare minSellUnlistedValue int outer
    /declare bankWildcards bool outer FALSE
    /declare sellWildcards bool outer FALSE
    /declare wildcardPrefixes string outer ""
    /declare packNum int outer 0
    /declare slotNum int outer 0
    /declare tributeItemsMoved int outer 0
    /declare tributePointsGained int outer 0
    /declare maxSlots int outer 0
    | Note: dryRun is declared in Main when needed, not here to avoid conflicts
    /declare itemID int outer 0
    /declare itemName string outer
    /declare itemValue int outer
    /declare itemLimit string outer
    /declare itemLimitUpper string outer
    /declare itemsBanked int outer 0
    /declare itemsTributed int outer 0
    /declare itemsDestroyed int outer 0
    /declare tlTag string outer "\at[turboLoot]"
    /declare announceDefaultTo string outer "echo"
    | Per-run warning dedupe for container autobank errors (keyed by container name)
    /declare BankContainerWarnedKeys string outer ""
    | Variables needed for Cleanup subroutine
    /declare abortingMacro bool outer FALSE
    /declare lootNoDropPromptReset string outer "always"
    | Dry-run collection variables (sell dryrun only)
    | Note: dryRun is declared in Main when needed, not here to avoid conflicts
    /declare dryRunSellCount int outer 0
    /declare dryRunSellTotalCopper int outer 0
    /declare returnToLeader bool outer FALSE
/return

|| ---------------------------------------------------------------------
|| LOAD SETTINGS MINIMAL (for BANK/SELL modes - faster startup)
|| ---------------------------------------------------------------------
Sub LoadSettingsMinimal(string modeParam)
    /declare altIniFile string local
    /declare modeUpper string local ${modeParam.Upper}
    /varset iniFile "../Config/turboloot.ini"
    /varset altIniFile "../Macros/turboloot.ini"
    /if (${Ini.File[${iniFile}].Exists}) {
        /echo [turboLoot] Using INI: ${iniFile}
    } else /if (${Ini.File[${altIniFile}].Exists}) {
        /varset iniFile ${altIniFile}
        /echo [turboLoot] Using INI: ${iniFile}
    } else {
        /echo [turboLoot] ERROR: No turboloot.ini found in ../Config or ../Macros.
        /echo [turboLoot] Please create turboloot.ini with a [Settings] section and [ItemLimits] section.
        /e3p off
        /deletevar turboLootRunning
        /if (${Defined[turboLootSafetyNet]}) /deletevar turboLootSafetyNet
        /endmac
    }
    | Only load essential settings for banking/selling (skip looting-specific settings)
    | New key: debug (legacy: ShowDebug)
    /declare debugSetting string local ${IniGetStringOrEmpty[Settings,debug]}
    /if (${debugSetting.Length}) {
        /declare debugUpper string local ${debugSetting.Upper.Replace[ ,]}
        /if (${debugUpper.Equal[ON]} || ${debugUpper.Equal[TRUE]} || ${debugUpper.Equal[YES]}) {
            /varset showDebug 1
        } else /if (${debugUpper.Equal[OFF]} || ${debugUpper.Equal[FALSE]} || ${debugUpper.Equal[NO]}) {
            /varset showDebug 0
        } else {
            /declare tmpDbg int local ${Int[${debugUpper}]}
            /if (${tmpDbg} == 0 && !${debugUpper.Equal[0]}) {
                /varset showDebug -1
            } else {
                /varset showDebug ${tmpDbg}
            }
        }
    } else {
        /declare legacyDebugSetting string local ${IniGetStringOrEmpty[Settings,ShowDebug]}
        /declare legacyDebugUpper string local ${legacyDebugSetting.Upper.Replace[ ,]}
        /if (${legacyDebugUpper.Equal[ON]} || ${legacyDebugUpper.Equal[TRUE]} || ${legacyDebugUpper.Equal[YES]}) {
            /varset showDebug 1
        } else /if (${legacyDebugUpper.Equal[OFF]} || ${legacyDebugUpper.Equal[FALSE]} || ${legacyDebugUpper.Equal[NO]}) {
            /varset showDebug 0
        } else {
            /declare tmpLegacyDbg int local ${Int[${legacyDebugUpper}]}
            /if (${tmpLegacyDbg} == 0 && !${legacyDebugUpper.Equal[0]}) {
                /varset showDebug -1
            } else {
                /varset showDebug ${tmpLegacyDbg}
            }
        }
    }

    | New key: announceLoot (legacy: announceLooted)
    /declare announceLootSetting string local ${IniGetStringOrEmpty[Settings,announceLoot]}
    /if (${announceLootSetting.Length}) {
        /declare lootUpper string local ${announceLootSetting.Upper.Replace[ ,]}
        /if (${lootUpper.Equal[ON]} || ${lootUpper.Equal[TRUE]} || ${lootUpper.Equal[YES]}) {
            /varset announceLooted 1
        } else /if (${lootUpper.Equal[OFF]} || ${lootUpper.Equal[FALSE]} || ${lootUpper.Equal[NO]}) {
            /varset announceLooted 0
        } else {
            /declare tmpLoot int local ${Int[${lootUpper}]}
            /if (${tmpLoot} == 0 && !${lootUpper.Equal[0]}) {
                /varset announceLooted -1
            } else {
                /varset announceLooted ${tmpLoot}
            }
        }
    } else {
        /declare legacyAnnounceLooted string local ${IniGetStringOrEmpty[Settings,announceLooted]}
        /declare legacyLootUpper string local ${legacyAnnounceLooted.Upper.Replace[ ,]}
        /if (${legacyLootUpper.Equal[ON]} || ${legacyLootUpper.Equal[TRUE]} || ${legacyLootUpper.Equal[YES]}) {
            /varset announceLooted 1
        } else /if (${legacyLootUpper.Equal[OFF]} || ${legacyLootUpper.Equal[FALSE]} || ${legacyLootUpper.Equal[NO]}) {
            /varset announceLooted 0
        } else {
            /declare tmpLegacyLoot int local ${Int[${legacyLootUpper}]}
            /if (${tmpLegacyLoot} == 0 && !${legacyLootUpper.Equal[0]}) {
                /varset announceLooted -1
            } else {
                /varset announceLooted ${tmpLegacyLoot}
            }
        }
    }

    | Minimal-mode validation (no full config validation runs in SELL/BANK/TRIBUTE fast path)
    /if (${showDebug} != 0 && ${showDebug} != 1) /varset showDebug 0
    /if (${announceLooted} != 0 && ${announceLooted} != 1) /varset announceLooted 1
    
    | New key: announceBankSellProgress
    | - 0/off disables progress/status chatter for BANK/SELL/TRIBUTE (still shows warnings/errors + summaries)
    | - 1/on enables progress/status chatter
    /declare bankSellProgressSetting string local ${IniGetStringOrEmpty[Settings,announceBankSellProgress]}
    /if (${bankSellProgressSetting.Length}) {
        /declare bankSellProgressUpper string local ${bankSellProgressSetting.Upper.Replace[ ,]}
        /if (${bankSellProgressUpper.Equal[0]} || ${bankSellProgressUpper.Equal[OFF]} || ${bankSellProgressUpper.Equal[FALSE]} || ${bankSellProgressUpper.Equal[NO]}) {
            /varset announceBankSellProgress 0
        } else /if (${bankSellProgressUpper.Equal[1]} || ${bankSellProgressUpper.Equal[ON]} || ${bankSellProgressUpper.Equal[TRUE]} || ${bankSellProgressUpper.Equal[YES]}) {
            /varset announceBankSellProgress 1
        } else {
            /declare tmpBankSellProgress int local ${Int[${bankSellProgressUpper}]}
            /if (${tmpBankSellProgress} > 0) /varset announceBankSellProgress 1
            /if (${tmpBankSellProgress} <= 0) /varset announceBankSellProgress 0
        }
    } else {
        /varset announceBankSellProgress 0
    }

    | New key: announceBankSellPerItem
    | - 0/off disables per-item messages for BANK/SELL/TRIBUTE/DESTROY (still shows warnings/errors + end summaries)
    | - 1/on enables per-item messages
    /declare bankSellPerItemSetting string local ${IniGetStringOrEmpty[Settings,announceBankSellPerItem]}
    /if (${bankSellPerItemSetting.Length}) {
        /declare bankSellPerItemUpper string local ${bankSellPerItemSetting.Upper.Replace[ ,]}
        /if (${bankSellPerItemUpper.Equal[0]} || ${bankSellPerItemUpper.Equal[OFF]} || ${bankSellPerItemUpper.Equal[FALSE]} || ${bankSellPerItemUpper.Equal[NO]}) {
            /varset announceBankSellPerItem 1
        } else /if (${bankSellPerItemUpper.Equal[1]} || ${bankSellPerItemUpper.Equal[ON]} || ${bankSellPerItemUpper.Equal[TRUE]} || ${bankSellPerItemUpper.Equal[YES]}) {
            /varset announceBankSellPerItem 1
        } else {
            /declare tmpBankSellPerItem int local ${Int[${bankSellPerItemUpper}]}
            /if (${tmpBankSellPerItem} > 0) /varset announceBankSellPerItem 1
            /if (${tmpBankSellPerItem} <= 0) /varset announceBankSellPerItem 0
        }
    } else {
        /varset announceBankSellPerItem 1
    }

    | New key: bankWildcards - bank items matching wildcard patterns (Spell:, Tome:, Song:, etc.)
    /declare bankWildcardsSetting string local ${IniGetStringOrEmpty[Settings,bankWildcards]}
    /if (${bankWildcardsSetting.Length}) {
        /declare bankWildcardsUpper string local ${bankWildcardsSetting.Upper.Replace[ ,]}
        /if (${bankWildcardsUpper.Equal[1]} || ${bankWildcardsUpper.Equal[ON]} || ${bankWildcardsUpper.Equal[TRUE]} || ${bankWildcardsUpper.Equal[YES]}) {
            /varset bankWildcards TRUE
        } else {
            /varset bankWildcards FALSE
        }
    } else {
        /varset bankWildcards FALSE
    }

    | New key: bankSellTributeAnnounceMethod (legacy: announceBankSell)
    | Aliases supported:
    | - announceDefaultTo (method)
    | - announceBankSellTributeTo (0/off disables, 1/on uses announceDefaultTo, otherwise method)
    /declare announceDefaultToSetting string local ${IniGetStringOrEmpty[Settings,announceDefaultTo]}
    /varset announceDefaultTo ${announceDefaultToSetting}
    /varset announceDefaultTo ${NormalizeAnnounceMethod[${announceDefaultTo}]}
    /declare announceDefaultUpper string local ${announceDefaultTo.Upper.Replace[ ,]}
    /if (!${announceDefaultTo.Length} || ${announceDefaultTo.Equal[NULL]} || ${announceDefaultTo.Equal[null]} || ${announceDefaultUpper.Equal[0]} || ${announceDefaultUpper.Equal[OFF]}) /varset announceDefaultTo "echo"
    /declare announceBankSellToSetting string local ${IniGetStringOrEmpty[Settings,announceBankSellTributeTo]}
    /declare bankSellAnnounceSetting string local ${IniGetStringOrEmpty[Settings,bankSellTributeAnnounceMethod]}
    /declare legacyAnnounceBankSellSetting string local ${IniGetStringOrEmpty[Settings,announceBankSell]}
    /declare bankSellToUpper string local
    /declare bankSellToMethod string local ""
    /declare bankSellToDisable bool local FALSE
    /if (${announceBankSellToSetting.Length}) {
        /varset bankSellToUpper ${announceBankSellToSetting.Upper.Replace[ ,]}
        /if (${bankSellToUpper.Equal[0]} || ${bankSellToUpper.Equal[OFF]}) {
            /varset bankSellToDisable TRUE
        } else /if (${bankSellToUpper.Equal[1]} || ${bankSellToUpper.Equal[ON]}) {
            /if (${announceDefaultToSetting.Length}) /varset bankSellToMethod ${announceDefaultToSetting}
        } else {
            /varset bankSellToMethod ${announceBankSellToSetting}
        }
    }
    | Resolve bank/sell/tribute announce method with normalization and safe fallbacks.
    | This prevents a blank/invalid legacy key from forcing fallback-to-echo.
    /declare bankSellResolved string local ""
    /if (${bankSellAnnounceSetting.Length}) {
        /varset bankSellResolved ${NormalizeAnnounceMethod[${bankSellAnnounceSetting}]}
    }
    | Prefer explicit alias (announceBankSellTributeTo) over legacy announceBankSell if both exist.
    /if (!${bankSellResolved.Length} && ${bankSellToDisable}) {
        /varset bankSellResolved "OFF"
    }
    /if (!${bankSellResolved.Length} && ${bankSellToMethod.Length}) {
        /varset bankSellResolved ${NormalizeAnnounceMethod[${bankSellToMethod}]}
    }
    /if (!${bankSellResolved.Length} && ${legacyAnnounceBankSellSetting.Length}) {
        /varset bankSellResolved ${NormalizeAnnounceMethod[${legacyAnnounceBankSellSetting}]}
    }
    /if (!${bankSellResolved.Length} && ${announceDefaultToSetting.Length}) {
        /varset bankSellResolved ${NormalizeAnnounceMethod[${announceDefaultToSetting}]}
    }
    /if (!${bankSellResolved.Length} || ${bankSellResolved.Equal[Null]}) {
        /varset bankSellResolved "echo"
    }
    /varset announceBankSell ${bankSellResolved}
    | Follow mode check (needed for cleanup - determines if follow should be paused/unpaused)
    | New key: followRestoreMode (legacy: RestoreFollowMode)
    /declare followModeSetting string local ${IniGetStringOrEmpty[Settings,followRestoreMode]}
    /if (!${followModeSetting.Length}) /varset followModeSetting ${IniGetStringOrEmpty[Settings,RestoreFollowMode]}
    /varset restoreFollowMode ${followModeSetting}
    /if (!${restoreFollowMode.Length} || ${restoreFollowMode.Equal[Null]}) /varset restoreFollowMode "NONE"
    /varset modeCheck ${restoreFollowMode.Upper.Replace[ ,]}
    | Skip StopFollowAndMovement during initialization for BANK/SELL modes (faster startup)
    | Cleanup will handle stopping follow/movement if needed
    | New key: followRestoreDriver (legacy: RestoreFollowDriver)
    /declare followDriverSetting string local ${IniGetStringOrEmpty[Settings,followRestoreDriver]}
    /if (${followDriverSetting.Length}) {
        /varset restoreFollowDriver ${followDriverSetting}
    } else {
        /varset restoreFollowDriver ${IniGetStringOrEmpty[Settings,RestoreFollowDriver]}
    }
    /if (!${restoreFollowDriver.Length} || ${restoreFollowDriver.Equal[Null]}) /varset restoreFollowDriver "AUTO"

    | New key: noDropPolicyOnExit (legacy: lootNoDropPromptReset)
    /declare noDropExitSetting string local ${IniGetStringOrEmpty[Settings,noDropPolicyOnExit]}
    /if (${noDropExitSetting.Length}) {
        /varset lootNoDropPromptReset ${noDropExitSetting}
    } else {
        /varset lootNoDropPromptReset ${IniGetStringOrEmpty[Settings,lootNoDropPromptReset]}
    }
    /if (!${lootNoDropPromptReset.Length}) /varset lootNoDropPromptReset "always"

    | DEBUG: show resolved announce routing (SELL/BANK/TRIBUTE fast path)
    /if (${showDebug}) {
        /echo [turboLoot] DBG(min) announceDefaultTo="${announceDefaultTo}" announceLoot=${announceLooted} bankSellMethod="${announceBankSell}"
        /echo [turboLoot] DBG(min) bankSellTributeAnnounceMethod="${bankSellAnnounceSetting}" announceBankSellTributeTo="${announceBankSellToSetting}" legacyAnnounceBankSell="${legacyAnnounceBankSellSetting}" bankSellResolved="${announceBankSell}"
    }

    | Sell functionality settings (only if in SELL mode)
    /if (${modeUpper.Equal[SELL]}) {
        | New key: SellUnlistedStackable - sell unlisted stackable items
        | OFF/0: disabled (default)
        | ON/1: sell any unlisted stackable item with vendor value
        /declare sellStackableSetting string local ${IniGetStringOrEmpty[Settings,SellUnlistedStackable]}
        /if (${sellStackableSetting.Length}) {
            /declare sellCheck string local ${sellStackableSetting.Upper.Replace[ ,]}
            /if (${sellCheck.Equal[ON]} || ${sellCheck.Equal[TRUE]} || ${sellCheck.Equal[YES]} || ${sellCheck.Equal[1]}) {
                /varset enableSellStackable 1
                /varset minSellStackableValue 0
            } else /if (${sellCheck.Equal[OFF]} || ${sellCheck.Equal[FALSE]} || ${sellCheck.Equal[NO]} || ${sellCheck.Equal[0]}) {
                /varset enableSellStackable 0
                /varset minSellStackableValue 0
            } else {
                | Default to OFF for any unrecognized value
                /varset enableSellStackable 0
                /varset minSellStackableValue 0
            }
        } else {
            | Legacy support: check old EnableSellStackable setting
            /varset enableSellStackable ${Int[${IniGetStringOrEmpty[Settings,EnableSellStackable]}]}
            /if (${enableSellStackable} != 0 && ${enableSellStackable} != 1) /varset enableSellStackable 0
            /varset minSellStackableValue 0
        }

        | New key: sellUnlistedItems - sell ANY unlisted item (not just stackables)
        | OFF/0: disabled (default)
        | ON/1: sell any unlisted item with vendor value
        /declare sellUnlistedSetting string local ${IniGetStringOrEmpty[Settings,sellUnlistedItems]}
        /if (${sellUnlistedSetting.Length}) {
            /declare sellUnlistedCheck string local ${sellUnlistedSetting.Upper.Replace[ ,]}
            /if (${sellUnlistedCheck.Equal[ON]} || ${sellUnlistedCheck.Equal[TRUE]} || ${sellUnlistedCheck.Equal[YES]} || ${sellUnlistedCheck.Equal[1]}) {
                /varset enableSellUnlistedValue 1
                /varset minSellUnlistedValue 0
            } else /if (${sellUnlistedCheck.Equal[OFF]} || ${sellUnlistedCheck.Equal[FALSE]} || ${sellUnlistedCheck.Equal[NO]} || ${sellUnlistedCheck.Equal[0]}) {
                /varset enableSellUnlistedValue 0
                /varset minSellUnlistedValue 0
            } else {
                | Default to OFF for any unrecognized value
                /varset enableSellUnlistedValue 0
                /varset minSellUnlistedValue 0
            }
        } else {
            /varset enableSellUnlistedValue 0
            /varset minSellUnlistedValue 0
        }

        | New key: sellWildcards
        | OFF/0: protect wildcards from auto-sell (but explicit Item=SELL still sells)
        | ON/1: auto-sell wildcards unless explicitly KEEP/IGNORE/BANK/TRIBUTE
        /declare sellWildcardsSetting string local ${IniGetStringOrEmpty[Settings,sellWildcards]}
        /if (${sellWildcardsSetting.Length}) {
            /declare sellWildcardsUpper string local ${sellWildcardsSetting.Upper.Replace[ ,]}
            /if (${sellWildcardsUpper.Equal[ON]} || ${sellWildcardsUpper.Equal[TRUE]} || ${sellWildcardsUpper.Equal[YES]}) {
                /varset sellWildcards 1
            } else /if (${sellWildcardsUpper.Equal[OFF]} || ${sellWildcardsUpper.Equal[FALSE]} || ${sellWildcardsUpper.Equal[NO]}) {
                /varset sellWildcards 0
            } else {
                /declare tmpSellWild int local ${Int[${sellWildcardsUpper}]}
                /if (${tmpSellWild} == 0 && !${sellWildcardsUpper.Equal[0]}) {
                    /varset sellWildcards 0
                } else {
                    /varset sellWildcards ${tmpSellWild}
                }
            }
        } else {
            /varset sellWildcards 0
        }
    }
    | returnToLeader - nav back to group leader after sell/bank/tribute/unload
    /declare rtlSetting string local ${IniGetStringOrEmpty[Settings,returnToLeader]}
    /if (${rtlSetting.Length}) {
        /declare rtlUpper string local ${rtlSetting.Upper.Replace[ ,]}
        /if (${rtlUpper.Equal[ON]} || ${rtlUpper.Equal[TRUE]} || ${rtlUpper.Equal[YES]} || ${rtlUpper.Equal[1]}) {
            /varset returnToLeader TRUE
        } else {
            /varset returnToLeader FALSE
        }
    }

    /call LoadWildcards
/return

| ---------------------------------------------------------------------
| LOAD SETTINGS
| ---------------------------------------------------------------------
Sub LoadSettings
    /declare altIniFile string local

    /varset iniFile "../Config/turboloot.ini"
    /varset altIniFile "../Macros/turboloot.ini"

    /if (${Ini.File[${iniFile}].Exists}) {
        /echo [turboLoot] Using INI: ${iniFile}
    } else /if (${Ini.File[${altIniFile}].Exists}) {
        /varset iniFile ${altIniFile}
        /echo [turboLoot] Using INI: ${iniFile}
    } else {
        /echo [turboLoot] ERROR: No turboloot.ini found in ../Config or ../Macros.
        /echo [turboLoot] Please create turboloot.ini with a [Settings] section and [ItemLimits] section.
        /echo [turboLoot] See documentation for required settings and item limit examples.
        /e3p off
        /deletevar turboLootRunning
        /if (${Defined[turboLootSafetyNet]}) /deletevar turboLootSafetyNet
        /endmac
    }

    | Early follow mode check (needed for StopFollowAndMovement - determines if /afollow should be paused)
    | New key: followRestoreMode (legacy: RestoreFollowMode)
    /declare followModeSetting string local ${IniGetStringOrEmpty[Settings,followRestoreMode]}
    /if (!${followModeSetting.Length}) /varset followModeSetting ${IniGetStringOrEmpty[Settings,RestoreFollowMode]}
    /varset restoreFollowMode ${followModeSetting}
    /if (!${restoreFollowMode.Length} || ${restoreFollowMode.Equal[Null]}) /varset restoreFollowMode "NONE"
    /varset modeCheck ${restoreFollowMode.Upper.Replace[ ,]}
    
    /if (${modeCheck.NotEqual[NONE]} && ${modeCheck.Length} && ${modeCheck.NotEqual[NULL]} && ${modeCheck.NotEqual[0]}) {
        /call StopFollowAndMovement
    }

    | New key: debug (legacy: ShowDebug)
    /declare debugSetting string local ${IniGetStringOrEmpty[Settings,debug]}
    /if (${debugSetting.Length}) {
        /declare debugUpper string local ${debugSetting.Upper.Replace[ ,]}
        /if (${debugUpper.Equal[ON]} || ${debugUpper.Equal[TRUE]} || ${debugUpper.Equal[YES]}) {
            /varset showDebug 1
        } else /if (${debugUpper.Equal[OFF]} || ${debugUpper.Equal[FALSE]} || ${debugUpper.Equal[NO]}) {
            /varset showDebug 0
        } else {
            /declare tmpDbg int local ${Int[${debugUpper}]}
            /if (${tmpDbg} == 0 && !${debugUpper.Equal[0]}) {
                /varset showDebug -1
            } else {
                /varset showDebug ${tmpDbg}
            }
        }
    } else {
        /declare legacyDebugSetting string local ${IniGetStringOrEmpty[Settings,ShowDebug]}
        /declare legacyDebugUpper string local ${legacyDebugSetting.Upper.Replace[ ,]}
        /if (${legacyDebugUpper.Equal[ON]} || ${legacyDebugUpper.Equal[TRUE]} || ${legacyDebugUpper.Equal[YES]}) {
            /varset showDebug 1
        } else /if (${legacyDebugUpper.Equal[OFF]} || ${legacyDebugUpper.Equal[FALSE]} || ${legacyDebugUpper.Equal[NO]}) {
            /varset showDebug 0
        } else {
            /declare tmpLegacyDbg int local ${Int[${legacyDebugUpper}]}
            /if (${tmpLegacyDbg} == 0 && !${legacyDebugUpper.Equal[0]}) {
                /varset showDebug -1
            } else {
                /varset showDebug ${tmpLegacyDbg}
            }
        }
    }

    | StopLootWhenAttacked: stop looting if aggressive mobs are in loot area (default: OFF)
    /declare stopLootSetting string local ${IniGetStringOrEmpty[Settings,StopLootWhenAttacked]}
    /if (${stopLootSetting.Length}) {
        /declare stopLootUpper string local ${stopLootSetting.Upper.Replace[ ,]}
        /if (${stopLootUpper.Equal[ON]} || ${stopLootUpper.Equal[TRUE]} || ${stopLootUpper.Equal[YES]} || ${stopLootUpper.Equal[1]}) {
            /varset stopLootWhenAttacked TRUE
        } else {
            /varset stopLootWhenAttacked FALSE
        }
    } else {
        /varset stopLootWhenAttacked FALSE
    }

    | AutoRsayInRaid: auto-switch announce method to rsay when in a raid (default: OFF)
    /declare autoRsaySetting string local ${IniGetStringOrEmpty[Settings,AutoRsayInRaid]}
    /if (${autoRsaySetting.Length}) {
        /declare autoRsayUpper string local ${autoRsaySetting.Upper.Replace[ ,]}
        /if (${autoRsayUpper.Equal[ON]} || ${autoRsayUpper.Equal[TRUE]} || ${autoRsayUpper.Equal[YES]} || ${autoRsayUpper.Equal[1]}) {
            /varset autoRsayInRaid TRUE
        } else {
            /varset autoRsayInRaid FALSE
        }
    } else {
        /varset autoRsayInRaid FALSE
    }

    | High-value looting:
    | - Preferred: lootHighValueMinPP is a combined setting: 0=off, 1=loot all non-stackable, N=loot non-stackable worth Npp+
    | - Legacy fallback: lootHighValue (0/1) + MinLootValue threshold
    /varset lootHighValueAll FALSE
    /declare highValueMinSetting string local ${IniGetStringOrEmpty[Settings,lootHighValueMinPP]}
    /if (${highValueMinSetting.Length}) {
        /declare hvCheck string local ${highValueMinSetting.Upper.Replace[ ,]}
        /declare hvVal int local 0
        /if (${hvCheck.Equal[ON]} || ${hvCheck.Equal[TRUE]} || ${hvCheck.Equal[YES]}) {
            /varset hvVal 1
        } else /if (${hvCheck.Equal[OFF]} || ${hvCheck.Equal[FALSE]} || ${hvCheck.Equal[NO]}) {
            /varset hvVal 0
        } else {
            /varset hvVal ${Int[${hvCheck}]}
        }
        /if (${hvVal} <= 0) {
            /varset enableHighValue 0
            /varset minLootValue 0
        } else /if (${hvVal} == 1) {
            /varset enableHighValue 1
            /varset minLootValue 0
            /varset lootHighValueAll TRUE
        } else {
            /varset enableHighValue 1
            /varset minLootValue ${hvVal}
        }
    } else {
        | New key: lootHighValue (legacy: EnableHighValue)
        /declare highValueSetting string local ${IniGetStringOrEmpty[Settings,lootHighValue]}
        /if (${highValueSetting.Length}) {
            /varset enableHighValue ${Int[${highValueSetting.Replace[ ,]}]}
        } else {
            /varset enableHighValue ${Int[${IniGetStringOrEmpty[Settings,EnableHighValue]}]}
        }
        /varset minLootValue ${Int[${IniGetStringOrEmpty[Settings,MinLootValue]}]}
        /if (!${minLootValue} || ${minLootValue} < 0) /varset minLootValue 0
    }

    | New key: lootStackableMinPP (legacy: LootStackable + MinStackableValue)
    /declare stackableSetting string local ${IniGetStringOrEmpty[Settings,lootStackableMinPP]}
    /if (${stackableSetting.Length}) {
        /declare stackableCheck string local ${stackableSetting.Upper.Replace[ ,]}
        /declare stackableVal int local 0
        /if (${stackableCheck.Equal[ON]} || ${stackableCheck.Equal[TRUE]} || ${stackableCheck.Equal[YES]}) {
            /varset stackableVal 1
        } else /if (${stackableCheck.Equal[OFF]} || ${stackableCheck.Equal[FALSE]} || ${stackableCheck.Equal[NO]}) {
            /varset stackableVal 0
        } else {
            /varset stackableVal ${Int[${stackableCheck}]}
        }
        /if (${stackableVal} <= 0) {
            /varset lootStackable 0
            /varset minStackableValue 0
        } else /if (${stackableVal} == 1) {
            /varset lootStackable 1
            /varset minStackableValue 0
        } else {
            /varset lootStackable 1
            /varset minStackableValue ${stackableVal}
        }
    } else {
        /varset lootStackable ${Int[${IniGetStringOrEmpty[Settings,LootStackable]}]}
        /varset minStackableValue ${Int[${IniGetStringOrEmpty[Settings,MinStackableValue]}]}
        /if (!${minStackableValue} || ${minStackableValue} < 0) /varset minStackableValue 0
    }


    | lootTribMinValue - loot unlisted items that meet a minimum tribute value threshold
    /declare lootTribMinValueSetting string local ${IniGetStringOrEmpty[Settings,lootTribMinValue]}
    /if (${lootTribMinValueSetting.Length}) {
        /declare lootTribMinUpper string local ${lootTribMinValueSetting.Upper.Replace[ ,]}
        /if (${lootTribMinUpper.Equal[OFF]} || ${lootTribMinUpper.Equal[NO]} || ${lootTribMinUpper.Equal[FALSE]} || ${lootTribMinUpper.Equal[0]}) {
            /varset lootTribMinValue 0
        } else {
            /varset lootTribMinValue ${Int[${lootTribMinValueSetting}]}
            /if (${lootTribMinValue} < 0) /varset lootTribMinValue 0
        }
    } else {
        /varset lootTribMinValue 0
    }

    | Aliases supported:
    | - announceDefaultTo
    | - announceLootTo / announceDestroyTo (both map to lootAnnounceMethod/announceMethod)
    | - announceBankSellTributeTo (maps to bankSellTributeAnnounceMethod/announceBankSell)
    | - announceLoreTo (maps to loreAnnounceMethod)
    | - announceSkipTo (maps to skipAnnounceMethod)
    /declare announceDefaultToSetting string local ${IniGetStringOrEmpty[Settings,announceDefaultTo]}
    /varset announceDefaultTo ${announceDefaultToSetting}
    /varset announceDefaultTo ${TrimSpaces[${announceDefaultTo}]}
    /declare announceDefaultUpper string local ${announceDefaultTo.Upper.Replace[ ,]}
    /if (!${announceDefaultTo.Length} || ${announceDefaultTo.Equal[NULL]} || ${announceDefaultTo.Equal[null]} || ${announceDefaultUpper.Equal[0]} || ${announceDefaultUpper.Equal[OFF]}) /varset announceDefaultTo "echo"
    /declare announceLootToSetting string local ${IniGetStringOrEmpty[Settings,announceLootTo]}
    /declare announceDestroyToSetting string local ${IniGetStringOrEmpty[Settings,announceDestroyTo]}
    /declare announceBankSellToSetting string local ${IniGetStringOrEmpty[Settings,announceBankSellTributeTo]}
    /declare announceLoreToSetting string local ${IniGetStringOrEmpty[Settings,announceLoreTo]}
    /declare announceSkipToSetting string local ${IniGetStringOrEmpty[Settings,announceSkipTo]}

    | New key: lootAnnounceMethod (legacy: announceMethod)
    | Aliases: announceDefaultTo, announceLootTo, announceDestroyTo
    /declare lootAnnounceSetting string local ${IniGetStringOrEmpty[Settings,lootAnnounceMethod]}
    /declare legacyAnnounceMethodSetting string local ${IniGetStringOrEmpty[Settings,announceMethod]}
    /declare lootToUpper string local
    /declare destroyToUpper string local
    /declare lootToMethod string local ""
    /declare destroyToMethod string local ""
    /if (${announceLootToSetting.Length}) {
        /varset lootToUpper ${announceLootToSetting.Upper.Replace[ ,]}
        /if (${lootToUpper.Equal[1]} || ${lootToUpper.Equal[ON]}) {
            | Explicit 1/ON: use announceDefaultTo if available
            /if (${announceDefaultToSetting.Length}) /varset lootToMethod ${announceDefaultToSetting}
        } else /if (!${lootToUpper.Equal[0]} && !${lootToUpper.Equal[OFF]}) {
            /varset lootToMethod ${announceLootToSetting}
        }
    }
    /if (${announceDestroyToSetting.Length}) {
        /varset destroyToUpper ${announceDestroyToSetting.Upper.Replace[ ,]}
        /if (${destroyToUpper.Equal[1]} || ${destroyToUpper.Equal[ON]}) {
            | Explicit 1/ON: use announceDefaultTo if available
            /if (${announceDefaultToSetting.Length}) /varset destroyToMethod ${announceDefaultToSetting}
        } else /if (!${destroyToUpper.Equal[0]} && !${destroyToUpper.Equal[OFF]}) {
            /varset destroyToMethod ${announceDestroyToSetting}
        }
    }
    /if (${lootToMethod.Length} && ${destroyToMethod.Length} && ${lootToMethod.NotEqual[${destroyToMethod}]}) {
        /echo [turboLoot] WARNING: announceLootTo and announceDestroyTo differ, but this macro uses one loot announce method. Using announceLootTo (${announceLootToSetting}).
    }
    /if (${lootAnnounceSetting.Length}) {
        /varset announceMethod ${lootAnnounceSetting}
    } else /if (${legacyAnnounceMethodSetting.Length}) {
        /varset announceMethod ${legacyAnnounceMethodSetting}
    } else /if (${lootToMethod.Length}) {
        /varset announceMethod ${lootToMethod}
    } else /if (${destroyToMethod.Length}) {
        /varset announceMethod ${destroyToMethod}
    } else /if (${announceDefaultToSetting.Length}) {
        /varset announceMethod ${announceDefaultToSetting}
    } else {
        /varset announceMethod ""
    }

    | New key: bankSellTributeAnnounceMethod (legacy: announceBankSell)
    | Alias: announceBankSellTributeTo (0/off disables, 1/on uses announceDefaultTo, otherwise method)
    /declare bankSellAnnounceSetting string local ${IniGetStringOrEmpty[Settings,bankSellTributeAnnounceMethod]}
    /declare legacyAnnounceBankSellSetting string local ${IniGetStringOrEmpty[Settings,announceBankSell]}
    /declare bankSellToUpper string local
    /declare bankSellToMethod string local ""
    /declare bankSellToDisable bool local FALSE
    /if (${announceBankSellToSetting.Length}) {
        /varset bankSellToUpper ${announceBankSellToSetting.Upper.Replace[ ,]}
        /if (${bankSellToUpper.Equal[0]} || ${bankSellToUpper.Equal[OFF]}) {
            /varset bankSellToDisable TRUE
        } else /if (${bankSellToUpper.Equal[1]} || ${bankSellToUpper.Equal[ON]}) {
            /if (${announceDefaultToSetting.Length}) /varset bankSellToMethod ${announceDefaultToSetting}
        } else {
            /varset bankSellToMethod ${announceBankSellToSetting}
        }
    }
    | Prefer explicit alias (announceBankSellTributeTo) over legacy announceBankSell if both exist.
    /if (${bankSellAnnounceSetting.Length}) {
        /varset announceBankSell ${bankSellAnnounceSetting}
    } else /if (${bankSellToDisable}) {
        /varset announceBankSell "OFF"
    } else /if (${bankSellToMethod.Length}) {
        /varset announceBankSell ${bankSellToMethod}
    } else /if (${legacyAnnounceBankSellSetting.Length}) {
        /varset announceBankSell ${legacyAnnounceBankSellSetting}
    } else /if (${announceDefaultToSetting.Length}) {
        /varset announceBankSell ${announceDefaultToSetting}
    } else {
        /varset announceBankSell ""
    }

    | New key: announceBankSellProgress
    | - 0/off disables progress/status chatter for BANK/SELL/TRIBUTE (still shows warnings/errors + summaries)
    | - 1/on enables progress/status chatter
    /declare bankSellProgressSetting string local ${IniGetStringOrEmpty[Settings,announceBankSellProgress]}
    /if (${bankSellProgressSetting.Length}) {
        /declare bankSellProgressUpper string local ${bankSellProgressSetting.Upper.Replace[ ,]}
        /if (${bankSellProgressUpper.Equal[0]} || ${bankSellProgressUpper.Equal[OFF]} || ${bankSellProgressUpper.Equal[FALSE]} || ${bankSellProgressUpper.Equal[NO]}) {
            /varset announceBankSellProgress 0
        } else /if (${bankSellProgressUpper.Equal[1]} || ${bankSellProgressUpper.Equal[ON]} || ${bankSellProgressUpper.Equal[TRUE]} || ${bankSellProgressUpper.Equal[YES]}) {
            /varset announceBankSellProgress 1
        } else {
            /declare tmpBankSellProgress int local ${Int[${bankSellProgressUpper}]}
            /if (${tmpBankSellProgress} > 0) /varset announceBankSellProgress 1
            /if (${tmpBankSellProgress} <= 0) /varset announceBankSellProgress 0
        }
    } else {
        /varset announceBankSellProgress 1
    }

    | New key: announceBankSellPerItem
    | - 0/off disables per-item messages for BANK/SELL/TRIBUTE/DESTROY (still shows warnings/errors + end summaries)
    | - 1/on enables per-item messages
    /declare bankSellPerItemSetting string local ${IniGetStringOrEmpty[Settings,announceBankSellPerItem]}
    /if (${bankSellPerItemSetting.Length}) {
        /declare bankSellPerItemUpper string local ${bankSellPerItemSetting.Upper.Replace[ ,]}
        /if (${bankSellPerItemUpper.Equal[0]} || ${bankSellPerItemUpper.Equal[OFF]} || ${bankSellPerItemUpper.Equal[FALSE]} || ${bankSellPerItemUpper.Equal[NO]}) {
            /varset announceBankSellPerItem 0
        } else /if (${bankSellPerItemUpper.Equal[1]} || ${bankSellPerItemUpper.Equal[ON]} || ${bankSellPerItemUpper.Equal[TRUE]} || ${bankSellPerItemUpper.Equal[YES]}) {
            /varset announceBankSellPerItem 1
        } else {
            /declare tmpBankSellPerItem int local ${Int[${bankSellPerItemUpper}]}
            /if (${tmpBankSellPerItem} > 0) /varset announceBankSellPerItem 1
            /if (${tmpBankSellPerItem} <= 0) /varset announceBankSellPerItem 0
        }
    } else {
        /varset announceBankSellPerItem 1
    }

    | New key: announceRunSummary
    | - 0/off disables
    | - 1/on/true/yes enables using lootAnnounceMethod/announceMethod
    | - echo/e3bc/gsay/rsay/say (or "t Name") enables and uses that method
    /declare summarySetting string local ${IniGetStringOrEmpty[Settings,announceRunSummary]}
    /declare summaryUpper string local
    /if (${summarySetting.Length}) {
        /varset summaryUpper ${summarySetting.Upper.Replace[ ,]}
        /if (${summaryUpper.Equal[0]} || ${summaryUpper.Equal[OFF]} || ${summaryUpper.Equal[FALSE]} || ${summaryUpper.Equal[NO]}) {
            /varset announceSummary 0
        } else /if (${summaryUpper.Equal[1]} || ${summaryUpper.Equal[ON]} || ${summaryUpper.Equal[TRUE]} || ${summaryUpper.Equal[YES]}) {
            /varset announceSummary 1
            /if (${announceDefaultToSetting.Length}) /varset announceSummaryMethod ${announceDefaultToSetting}
            /if (!${announceSummaryMethod.Length}) /varset announceSummaryMethod ${announceMethod}
        } else {
            /varset announceSummary 1
            /varset announceSummaryMethod ${summarySetting}
        }
    } else {
        | Legacy: announceSummary (0/1)
        /varset announceSummary ${Int[${IniGetStringOrEmpty[Settings,announceSummary]}]}
        /if (${announceSummary} == 1) /varset announceSummaryMethod ${announceMethod}
    }

    | New key: announceLoot (legacy: announceLooted)
    /declare announceLootSetting string local ${IniGetStringOrEmpty[Settings,announceLoot]}
    /declare legacyAnnounceLooted string local ${IniGetStringOrEmpty[Settings,announceLooted]}
    /if (${announceLootSetting.Length}) {
        /declare lootUpper string local ${announceLootSetting.Upper.Replace[ ,]}
        /if (${lootUpper.Equal[ON]} || ${lootUpper.Equal[TRUE]} || ${lootUpper.Equal[YES]}) {
            /varset announceLooted 1
        } else /if (${lootUpper.Equal[OFF]} || ${lootUpper.Equal[FALSE]} || ${lootUpper.Equal[NO]}) {
            /varset announceLooted 0
        } else {
            /declare tmpLoot int local ${Int[${lootUpper}]}
            /if (${tmpLoot} == 0 && !${lootUpper.Equal[0]}) {
                /varset announceLooted -1
            } else {
                /varset announceLooted ${tmpLoot}
            }
        }
    } else {
        /declare legacyLootUpper string local ${legacyAnnounceLooted.Upper.Replace[ ,]}
        /if (${legacyLootUpper.Equal[ON]} || ${legacyLootUpper.Equal[TRUE]} || ${legacyLootUpper.Equal[YES]}) {
            /varset announceLooted 1
        } else /if (${legacyLootUpper.Equal[OFF]} || ${legacyLootUpper.Equal[FALSE]} || ${legacyLootUpper.Equal[NO]}) {
            /varset announceLooted 0
        } else {
            /declare tmpLegacyLoot int local ${Int[${legacyLootUpper}]}
            /if (${tmpLegacyLoot} == 0 && !${legacyLootUpper.Equal[0]}) {
                /varset announceLooted -1
            } else {
                /varset announceLooted ${tmpLegacyLoot}
            }
        }
    }
    | Alias: announceLootTo can enable/disable loot announcements (0/off, 1/on, method)
    /if (${announceLootToSetting.Length} && !${announceLootSetting.Length} && !${legacyAnnounceLooted.Length}) {
        /varset lootToUpper ${announceLootToSetting.Upper.Replace[ ,]}
        /if (${lootToUpper.Equal[0]} || ${lootToUpper.Equal[OFF]}) {
            /varset announceLooted 0
        } else {
            /varset announceLooted 1
        }
    }

    | New key: announceDestroy (legacy: announceDestroyed)
    /declare announceDestroySetting string local ${IniGetStringOrEmpty[Settings,announceDestroy]}
    /declare legacyAnnounceDestroyed string local ${IniGetStringOrEmpty[Settings,announceDestroyed]}
    /if (${announceDestroySetting.Length}) {
        /declare destroyUpper string local ${announceDestroySetting.Upper.Replace[ ,]}
        /if (${destroyUpper.Equal[ON]} || ${destroyUpper.Equal[TRUE]} || ${destroyUpper.Equal[YES]}) {
            /varset announceDestroyed 1
        } else /if (${destroyUpper.Equal[OFF]} || ${destroyUpper.Equal[FALSE]} || ${destroyUpper.Equal[NO]}) {
            /varset announceDestroyed 0
        } else {
            /declare tmpDestroy int local ${Int[${destroyUpper}]}
            /if (${tmpDestroy} == 0 && !${destroyUpper.Equal[0]}) {
                /varset announceDestroyed -1
            } else {
                /varset announceDestroyed ${tmpDestroy}
            }
        }
    } else {
        /declare legacyDestroyUpper string local ${legacyAnnounceDestroyed.Upper.Replace[ ,]}
        /if (${legacyDestroyUpper.Equal[ON]} || ${legacyDestroyUpper.Equal[TRUE]} || ${legacyDestroyUpper.Equal[YES]}) {
            /varset announceDestroyed 1
        } else /if (${legacyDestroyUpper.Equal[OFF]} || ${legacyDestroyUpper.Equal[FALSE]} || ${legacyDestroyUpper.Equal[NO]}) {
            /varset announceDestroyed 0
        } else {
            /declare tmpLegacyDestroy int local ${Int[${legacyDestroyUpper}]}
            /if (${tmpLegacyDestroy} == 0 && !${legacyDestroyUpper.Equal[0]}) {
                /varset announceDestroyed -1
            } else {
                /varset announceDestroyed ${tmpLegacyDestroy}
            }
        }
    }
    | Alias: announceDestroyTo can enable/disable destroy announcements (0/off, 1/on, method)
    /if (${announceDestroyToSetting.Length} && !${announceDestroySetting.Length} && !${legacyAnnounceDestroyed.Length}) {
        /varset destroyToUpper ${announceDestroyToSetting.Upper.Replace[ ,]}
        /if (${destroyToUpper.Equal[0]} || ${destroyToUpper.Equal[OFF]}) {
            /varset announceDestroyed 0
        } else {
            /varset announceDestroyed 1
        }
    }

    | New key: loreAnnounceMethod (legacy: announceLore + announceLoreMethod)
    /declare loreAnnounceSetting string local ${IniGetStringOrEmpty[Settings,loreAnnounceMethod]}
    /if (${loreAnnounceSetting.Length}) {
        /declare loreCheck string local ${loreAnnounceSetting.Replace[ ,]}
        /if (${loreCheck.Equal[0]}) {
            /varset announceLore 0
            /varset announceLoreMethod "echo"
        } else /if (${loreCheck.Equal[1]}) {
            /varset announceLore 1
            /varset announceLoreMethod ${announceMethod}
        } else {
            /varset announceLore 1
            /varset announceLoreMethod ${loreAnnounceSetting}
        }
    } else {
        /if (${announceLoreToSetting.Length}) {
            /declare loreToCheck string local ${announceLoreToSetting.Upper.Replace[ ,]}
            /if (${loreToCheck.Equal[0]} || ${loreToCheck.Equal[OFF]}) {
                /varset announceLore 0
                /varset announceLoreMethod "echo"
            } else /if (${loreToCheck.Equal[1]} || ${loreToCheck.Equal[ON]}) {
                /varset announceLore 1
                /if (${announceDefaultToSetting.Length}) /varset announceLoreMethod ${announceDefaultToSetting}
                /if (!${announceLoreMethod.Length}) /varset announceLoreMethod ${announceMethod}
            } else {
                /varset announceLore 1
                /varset announceLoreMethod ${announceLoreToSetting}
            }
        } else {
            /varset announceLore ${Int[${IniGetStringOrEmpty[Settings,announceLore]}]}
            /varset announceLoreMethod ${IniGetStringOrEmpty[Settings,announceLoreMethod]}
        }
    }

    | New key: skipAnnounceMethod (legacy: announceSkipped + announceSkippedMethod)
    /declare skipAnnounceSetting string local ${IniGetStringOrEmpty[Settings,skipAnnounceMethod]}
    /declare explicitSkipTo string local ""
    /if (${announceSkipToSetting.Length}) {
        /declare skipToUpper2 string local ${announceSkipToSetting.Upper.Replace[ ,]}
        /if (!${skipToUpper2.Equal[0]} && !${skipToUpper2.Equal[OFF]} && !${skipToUpper2.Equal[1]} && !${skipToUpper2.Equal[ON]}) {
            /varset explicitSkipTo ${announceSkipToSetting}
        }
    }
    /if (${skipAnnounceSetting.Length}) {
        /declare skipCheck string local ${skipAnnounceSetting.Replace[ ,]}
        /if (${skipCheck.Equal[0]}) {
            /varset announceSkipped 0
            /varset announceSkippedMethod ${announceMethod}
        } else /if (${skipCheck.Equal[1]}) {
            /varset announceSkipped 1
            /if (${explicitSkipTo.Length}) {
                /varset announceSkippedMethod ${explicitSkipTo}
            } else {
                /varset announceSkippedMethod ${announceMethod}
            }
        } else {
            /varset announceSkipped 1
            /varset announceSkippedMethod ${skipAnnounceSetting}
        }
    } else {
        /if (${announceSkipToSetting.Length}) {
            /declare skipToCheck string local ${announceSkipToSetting.Upper.Replace[ ,]}
            /if (${skipToCheck.Equal[0]} || ${skipToCheck.Equal[OFF]}) {
                /varset announceSkipped 0
                /varset announceSkippedMethod ${announceMethod}
            } else /if (${skipToCheck.Equal[1]} || ${skipToCheck.Equal[ON]}) {
                /varset announceSkipped 1
                /if (${announceDefaultToSetting.Length}) /varset announceSkippedMethod ${announceDefaultToSetting}
                /if (!${announceSkippedMethod.Length}) /varset announceSkippedMethod ${announceMethod}
            } else {
                /varset announceSkipped 1
                /varset announceSkippedMethod ${announceSkipToSetting}
            }
        } else {
            /declare legacyAnnounceSkipped string local ${IniGetStringOrEmpty[Settings,announceSkipped]}
            /varset announceSkipped ${Int[${legacyAnnounceSkipped}]}
            /varset announceSkippedMethod ${IniGetStringOrEmpty[Settings,announceSkippedMethod]}
            | Default: announce skips when legacy key not set (user hasn't explicitly disabled)
            /if (!${legacyAnnounceSkipped.Length}) /varset announceSkipped 1
        }
    }

    | New key: lootRadiusFeet (legacy: lootDistance)
    /declare lootRadiusSetting string local ${IniGetStringOrEmpty[Settings,lootRadiusFeet]}
    /if (${lootRadiusSetting.Length}) {
        /varset lootDistance ${Int[${lootRadiusSetting.Replace[ ,]}]}
    } else {
        /varset lootDistance ${Int[${IniGetStringOrEmpty[Settings,lootDistance]}]}
    }
    /if (!${lootDistance} || ${lootDistance} < 1) /varset lootDistance 50

    | New key: finalSweep (default ON)
    | Runs one extra retry pass at end when all corpses are alerted (helps with lag/pathing misses)
    /declare finalSweepSetting string local ${IniGetStringOrEmpty[Settings,finalSweep]}
    /if (${finalSweepSetting.Length}) {
        /declare finalSweepUpper string local ${finalSweepSetting.Upper.Replace[ ,]}
        /if (${finalSweepUpper.Equal[ON]} || ${finalSweepUpper.Equal[TRUE]} || ${finalSweepUpper.Equal[YES]} || ${finalSweepUpper.Equal[1]}) {
            /varset finalSweepEnabled 1
        } else /if (${finalSweepUpper.Equal[OFF]} || ${finalSweepUpper.Equal[FALSE]} || ${finalSweepUpper.Equal[NO]} || ${finalSweepUpper.Equal[0]}) {
            /varset finalSweepEnabled 0
        } else {
            /declare tmpFinalSweep int local ${Int[${finalSweepUpper}]}
            /if (${tmpFinalSweep} != 0 && ${tmpFinalSweep} != 1) {
                /echo [turboLoot] WARNING: finalSweep must be ON/OFF/1/0. Defaulting to ON.
                /varset finalSweepEnabled 1
            } else {
                /varset finalSweepEnabled ${tmpFinalSweep}
            }
        }
    } else {
        /varset finalSweepEnabled 1
    }

    | New key: finalSweepRadiusFeet (0 = use lootRadiusFeet)
    /declare finalSweepRadiusSetting string local ${IniGetStringOrEmpty[Settings,finalSweepRadiusFeet]}
    /if (${finalSweepRadiusSetting.Length}) {
        /varset finalSweepRadiusFeet ${Int[${finalSweepRadiusSetting.Replace[ ,]}]}
        /if (${finalSweepRadiusFeet} < 0) /varset finalSweepRadiusFeet 0
    } else {
        /varset finalSweepRadiusFeet 0
    }

    | New key: inventoryWarnSlots (legacy: announceInventoryAlmostFull, MinFreeInventory)
    /declare invWarnSetting string local ${IniGetStringOrEmpty[Settings,inventoryWarnSlots]}
    /if (${invWarnSetting.Length}) {
        /varset announceInventoryAlmostFull ${Int[${invWarnSetting.Replace[ ,]}]}
    } else {
        /varset announceInventoryAlmostFull ${Int[${IniGetStringOrEmpty[Settings,announceInventoryAlmostFull]}]}
        /if (!${announceInventoryAlmostFull} || ${announceInventoryAlmostFull} < 0) {
            /varset announceInventoryAlmostFull ${Int[${IniGetStringOrEmpty[Settings,MinFreeInventory]}]}
            /if (!${announceInventoryAlmostFull} || ${announceInventoryAlmostFull} < 0) /varset announceInventoryAlmostFull 5
        }
    }

    | New key: followRestoreDriver (legacy: RestoreFollowDriver)
    /declare followDriverSetting string local ${IniGetStringOrEmpty[Settings,followRestoreDriver]}
    /if (${followDriverSetting.Length}) {
        /varset restoreFollowDriver ${followDriverSetting}
    } else {
        /varset restoreFollowDriver ${IniGetStringOrEmpty[Settings,RestoreFollowDriver]}
    }
    /if (!${restoreFollowDriver.Length} || ${restoreFollowDriver.Equal[Null]}) /varset restoreFollowDriver "AUTO"
    
    | New key: SellUnlistedStackable - sell unlisted stackable items
    | OFF/0: disabled (default)
    | ON/1: sell any unlisted stackable item with vendor value
    /declare sellStackableSetting string local ${IniGetStringOrEmpty[Settings,SellUnlistedStackable]}
    /if (${sellStackableSetting.Length}) {
        /declare sellCheck string local ${sellStackableSetting.Upper.Replace[ ,]}
        /if (${sellCheck.Equal[ON]} || ${sellCheck.Equal[TRUE]} || ${sellCheck.Equal[YES]} || ${sellCheck.Equal[1]}) {
            /varset enableSellStackable 1
            /varset minSellStackableValue 0
        } else /if (${sellCheck.Equal[OFF]} || ${sellCheck.Equal[FALSE]} || ${sellCheck.Equal[NO]} || ${sellCheck.Equal[0]}) {
            /varset enableSellStackable 0
            /varset minSellStackableValue 0
        } else {
            | Default to OFF for any unrecognized value
            /varset enableSellStackable 0
            /varset minSellStackableValue 0
        }
    } else {
        | Legacy support: check old EnableSellStackable setting
        /varset enableSellStackable ${Int[${IniGetStringOrEmpty[Settings,EnableSellStackable]}]}
        /if (${enableSellStackable} != 0 && ${enableSellStackable} != 1) /varset enableSellStackable 0
        /varset minSellStackableValue 0
    }
    
    /if (!${announceMethod.Length} || ${announceMethod.Equal[Null]}) /varset announceMethod ${announceDefaultTo}
    /if (!${announceLoreMethod.Length} || ${announceLoreMethod.Equal[Null]}) /varset announceLoreMethod ${announceDefaultTo}
    /if (!${announceSkippedMethod.Length} || ${announceSkippedMethod.Equal[Null]}) /varset announceSkippedMethod ${announceDefaultTo}
    /if (!${announceBankSell.Length} || ${announceBankSell.Equal[Null]}) /varset announceBankSell ${announceDefaultTo}
    /if (!${announceSummaryMethod.Length} || ${announceSummaryMethod.Equal[Null]}) /varset announceSummaryMethod ${announceDefaultTo}
    | Final sanitize: guard against hidden whitespace (tabs) producing empty commands
    /varset announceMethod ${NormalizeAnnounceMethod[${announceMethod}]}
    /varset announceLoreMethod ${NormalizeAnnounceMethod[${announceLoreMethod}]}
    /varset announceSkippedMethod ${NormalizeAnnounceMethod[${announceSkippedMethod}]}
    /varset announceBankSell ${NormalizeAnnounceMethod[${announceBankSell}]}
    /varset announceSummaryMethod ${NormalizeAnnounceMethod[${announceSummaryMethod}]}
    /if (!${announceMethod.Length}) /varset announceMethod ${announceDefaultTo}
    /if (!${announceLoreMethod.Length}) /varset announceLoreMethod ${announceDefaultTo}
    /if (!${announceSkippedMethod.Length}) /varset announceSkippedMethod ${announceDefaultTo}
    /if (!${announceBankSell.Length}) /varset announceBankSell ${announceDefaultTo}
    /if (!${announceSummaryMethod.Length}) /varset announceSummaryMethod ${announceDefaultTo}
    
    | Final override: if announceSkipTo is explicitly set to a method (say/gsay/rsay/t Name),
    | force skipped announcements to that method regardless of other legacy skip settings.
    /if (${announceSkipToSetting.Length}) {
        /declare skipToFinalUpper string local ${announceSkipToSetting.Upper.Replace[ ,]}
        /if (${skipToFinalUpper.Equal[0]} || ${skipToFinalUpper.Equal[OFF]}) {
            /varset announceSkipped 0
        } else /if (!${skipToFinalUpper.Equal[1]} && !${skipToFinalUpper.Equal[ON]}) {
            /varset announceSkipped 1
            /varset announceSkippedMethod ${NormalizeAnnounceMethod[${announceSkipToSetting}]}
        }
    }

    | AutoRsayInRaid: if enabled and in a raid, override announce methods to rsay
    /if (${autoRsayInRaid} && ${Raid.Members} > 0) {
        /if (${showDebug}) /echo [turboLoot] AutoRsayInRaid: In raid with ${Raid.Members} members, switching announce methods to rsay
        /varset announceMethod rsay
        /varset announceLoreMethod rsay
        /varset announceSkippedMethod rsay
        /varset announceSummaryMethod rsay
    }
  	
    | this controls the display to prompt if we want to loot no drop items
    | always - always display the prompt, will not loot by default
    | never - never display the prompt, will loot no drop
    | not usable - only display the prompt for items that are not usable for your class, will loot no drop that are usable ****NOT RECOMMENDED****
    | New keys: noDropPolicy + noDropPolicyOnExit (legacy: lootNoDropPrompt + lootNoDropPromptReset)
    /declare noDropSetting string local ${IniGetStringOrEmpty[Settings,noDropPolicy]}
    /if (${noDropSetting.Length}) {
        /varset lootNoDropPrompt ${noDropSetting}
    } else {
        /varset lootNoDropPrompt ${IniGetStringOrEmpty[Settings,lootNoDropPrompt]}
    }
    /declare noDropExitSetting string local ${IniGetStringOrEmpty[Settings,noDropPolicyOnExit]}
    /if (${noDropExitSetting.Length}) {
        /varset lootNoDropPromptReset ${noDropExitSetting}
    } else {
        /varset lootNoDropPromptReset ${IniGetStringOrEmpty[Settings,lootNoDropPromptReset]}
    }
    /docommand /lootnodrop ${lootNoDropPrompt}

    | DEBUG: show resolved announce routing (helps diagnose "only DONE LOOTING shows")
    /if (${showDebug}) {
        /echo [turboLoot] DBG announceDefaultTo="${announceDefaultTo}" announceMethod="${announceMethod}" announceLoot=${announceLooted} announceDestroy=${announceDestroyed} announceLore=${announceLore} announceSkipped=${announceSkipped} announceRunSummary=${announceSummary}
        /echo [turboLoot] DBG loreMethod="${announceLoreMethod}" skipMethod="${announceSkippedMethod}" bankSellMethod="${announceBankSell}"
        /echo [turboLoot] DBG announceSkipToSetting="${announceSkipToSetting}" skipAnnounceSetting="${skipAnnounceSetting}"
    }

    | ---------------------------------------------------------------------
    | CONFIG VALIDATION
    | ---------------------------------------------------------------------
    | Validate booleans (0 or 1)
    /if (${showDebug} != 0 && ${showDebug} != 1) {
        /echo [turboLoot] WARNING: ShowDebug must be 0 or 1, defaulting to 0
        /varset showDebug 0
    }
    /if (${enableHighValue} != 0 && ${enableHighValue} != 1) {
        /echo [turboLoot] WARNING: EnableHighValue must be 0 or 1, defaulting to 0
        /varset enableHighValue 0
    }
    /if (${lootStackable} != 0 && ${lootStackable} != 1) {
        /echo [turboLoot] WARNING: LootStackable must be 0 or 1, defaulting to 0
        /varset lootStackable 0
    }
    /if (${announceSkipped} != 0 && ${announceSkipped} != 1) {
        /echo [turboLoot] WARNING: announceSkipped must be 0 or 1, defaulting to 1
        /varset announceSkipped 1
    }
    /if (${announceLooted} != 0 && ${announceLooted} != 1) {
        /echo [turboLoot] WARNING: announceLooted must be 0 or 1, defaulting to 1
        /varset announceLooted 1
    }
    /if (${announceLore} != 0 && ${announceLore} != 1) {
        /echo [turboLoot] WARNING: announceLore must be 0 or 1, defaulting to 1
        /varset announceLore 1
    }
    /if (${announceDestroyed} != 0 && ${announceDestroyed} != 1) {
        /echo [turboLoot] WARNING: announceDestroyed must be 0 or 1, defaulting to 1
        /varset announceDestroyed 1
    }
    | Default announceSummary to 0 if not set or invalid
    /if (${announceSummary} < 0 || ${announceSummary} > 1) {
        /varset announceSummary 0
    }
    /if (!${announceSummaryMethod.Length} || ${announceSummaryMethod.Equal[Null]} || ${announceSummaryMethod.Equal[NULL]} || ${announceSummaryMethod.Equal[null]}) {
        /varset announceSummaryMethod ${announceMethod}
    }
    /declare summaryMethodUpper string local ${announceSummaryMethod.Upper}
    /if (${announceSummary} == 1 && !${summaryMethodUpper.Left[4].Equal[ECHO]} && !${summaryMethodUpper.Left[4].Equal[E3BC]} && !${summaryMethodUpper.Left[4].Equal[GSAY]} && !${summaryMethodUpper.Left[4].Equal[RSAY]} && !${summaryMethodUpper.Left[3].Equal[SAY]} && !${summaryMethodUpper.Left[1].Equal[G]} && !${summaryMethodUpper.Left[2].Equal[RS]} && !${summaryMethodUpper.Left[2].Equal[T ]} && !${summaryMethodUpper.Left[5].Equal[TELL ]}) {
        /echo [turboLoot] WARNING: announceRunSummary must be OFF/0, ON/1, echo/e3bc/gsay/rsay/say, or t Name. Defaulting to ${announceMethod}.
        /varset announceSummaryMethod ${announceMethod}
    }

    | Validate numbers
    /if (${minLootValue} < 0) {
        /echo [turboLoot] WARNING: MinLootValue (${minLootValue}) is negative, defaulting to 0
        /varset minLootValue 0
    }
    /if (${minStackableValue} < 0) {
        /echo [turboLoot] WARNING: MinStackableValue (${minStackableValue}) is negative, defaulting to 0
        /varset minStackableValue 0
    }
    /if (!${lootDistance} || ${lootDistance} < 1) {
        /echo [turboLoot] WARNING: lootDistance (${lootDistance}) is invalid, defaulting to 50
        /varset lootDistance 50
    }
    /if (${lootDistance} > 100) {
        /echo [turboLoot] WARNING: lootDistance (${lootDistance}) seems high, ensure it's in feet.
    }
    /if (${announceInventoryAlmostFull} < 0) {
        /echo [turboLoot] WARNING: announceInventoryAlmostFull (${announceInventoryAlmostFull}) is negative, defaulting to 5
        /varset announceInventoryAlmostFull 5
    }

    | Validate strings
    /if (!${lootNoDropPrompt.Length}) {
        /echo [turboLoot] WARNING: lootNoDropPrompt not set in INI, defaulting to "always"
        /varset lootNoDropPrompt "always"
    }
    /if (!${lootNoDropPromptReset.Length}) {
        /echo [turboLoot] WARNING: lootNoDropPromptReset not set in INI, defaulting to "always"
        /varset lootNoDropPromptReset "always"
    }
    /if (!${announceMethod.Length} || ${announceMethod.Equal[null]}) {
        /echo [turboLoot] WARNING: announceMethod not set, defaulting to "echo"
        /varset announceMethod "echo"
    }
    /if (!${announceLoreMethod.Length} || ${announceLoreMethod.Equal[null]}) {
        /echo [turboLoot] WARNING: announceLoreMethod not set, defaulting to "echo"
        /varset announceLoreMethod "echo"
    }
    /if (!${announceSkippedMethod.Length} || ${announceSkippedMethod.Equal[null]}) {
        /echo [turboLoot] WARNING: announceSkippedMethod not set, defaulting to announceMethod
        /varset announceSkippedMethod ${announceMethod}
    }
    /if (!${announceBankSell.Length} || ${announceBankSell.Equal[null]}) {
        /echo [turboLoot] WARNING: announceBankSell not set, defaulting to "echo"
        /varset announceBankSell "echo"
    }

    /if (${showDebug}) /echo ${tlTag} \at[INI] \ag${iniFile}
    /if (${enableHighValue} && ${lootHighValueAll}) {
        /if (${showDebug}) /echo [turboLoot] High-value looting ENABLED: Looting ALL non-stackable items (no value threshold)
    } else /if (${enableHighValue} && ${minLootValue} > 0) {
        /if (${showDebug}) /echo [turboLoot] High-value looting ENABLED: Looting non-stackable items worth ${minLootValue} platinum or more
    } else /if (${enableHighValue} && ${minLootValue} <= 0) {
        /echo [turboLoot] WARNING: EnableHighValue is ON but MinLootValue is ${minLootValue}. High-value looting is DISABLED.
        /echo [turboLoot] Set MinLootValue to a positive number (e.g., 100) or use lootHighValueMinPP=1 to loot all non-stackable.
    }
    /if (${lootStackable} && ${minStackableValue} > 0) {
        /if (${showDebug}) /echo [turboLoot] Stackable value threshold ENABLED: Looting stackable items worth ${minStackableValue} platinum or more
    } else     /if (${lootStackable} && ${minStackableValue} <= 0) {
        /if (${showDebug}) /echo [turboLoot] Stackable looting ENABLED: Looting all stackable items (no value threshold)
    }
    /if (${lootTribMinValue} > 0 && ${showDebug}) {
        /echo [turboLoot] lootTribMinValue=${lootTribMinValue}: Looting unlisted items with tribute>=${lootTribMinValue} or value>=${lootTribMinValue}pp as TRIBUTE
    }
    
    /if (${showDebug}) {
        /echo [turboLoot] NOTE: Only items listed in [ItemLimits] will be looted (unless wildcard/high-value/stackable/lootTribMinValue).
        /echo [turboLoot] lootTribMinValue=${lootTribMinValue} - unlisted items with tribute>=${lootTribMinValue} (or value>=${lootTribMinValue}pp) looted as TRIBUTE
        /echo [turboLoot] Add items to turboloot.ini [ItemLimits] section to loot specific items.
        /echo [turboLoot] Use "ALL" or "KEEP" or a number (#) to loot and keep; "SELL"/"BANK"/"TRIBUTE"/"DESTROY" for actions; "IGNORE" to skip.
    }

    /call LoadWildcards
/return

| ---------------------------------------------------------------------
| PRECHECKS
| ---------------------------------------------------------------------
Sub PreChecks
    | handle FD early and exit like original
    /if (${Me.Feigning}) {
        /if (${Me.Grouped}) /docommand /${announceMethod} [FEIGNED] Currently FD and not looting
        /docommand /lootnodrop ${lootNoDropPromptReset}
        /varset turboLootRunning FALSE
        /endmac
    }

    | cooldown guard
    /if (${Defined[turboLootCooldown]}) {
        /if (${showDebug}) /echo [turboLoot] Cooldown active. Skipping to prevent event spam.
        /e3p off
        /deletevar turboLootRunning
        /if (${Defined[turboLootSafetyNet]}) /deletevar turboLootSafetyNet
        /return
    }

    | check for corpses in range
    /declare corpseCheckRetries int local 0
    /declare maxCorpseCheckRetries int local 2
:checkCorpses
    /declare corpseCount int local ${SpawnCount[npccorpse radius ${lootDistance}]}
    /if (!${corpseCount}) /varset corpseCount ${SpawnCount[corpse radius ${lootDistance}]}
    /if (!${corpseCount}) {
        /varcalc corpseCheckRetries ${corpseCheckRetries}+1
        /if (${corpseCheckRetries} <= ${maxCorpseCheckRetries}) {
            /if (${showDebug}) /echo [turboLoot] No corpses found within ${lootDistance}. Attempting spawn list refresh (retry ${corpseCheckRetries}/${maxCorpseCheckRetries})...
            | Try to refresh spawn list - hidecorpse toggle can help refresh MQ2's spawn list
            /squelch /hidecorpse all
            /delay 1
            /squelch /hidecorpse none
            /delay 1
            | Try #corpsefix if available (MQ2 command to refresh corpse data)
            /squelch /docommand #corpsefix
            /delay 1
            /goto :checkCorpses
        }
        /if (${showDebug}) /echo [turboLoot] No corpses found within ${lootDistance} after ${maxCorpseCheckRetries} retries. Exiting.
        /deletevar turboLootRunning
        /declare turboLootCooldown int global 1
        /timed 50 /deletevar turboLootCooldown
        /call Cleanup
        /return
    }
/return

| ---------------------------------------------------------------------
| PAUSE E3 LOGIC
| ---------------------------------------------------------------------
Sub PauseE3Logic
    /e3p on
    /delay 1

    | Safety net: ensure E3P resumes even if macro runs too long (10 minutes)
    /timed 6000 /if (${Macro.Name.Equal[turboLoot]}) /echo [turboLoot] SAFETY NET: Macro still running after 10 minutes - resuming E3Next (/e3p off).
    /timed 6000 /if (${Macro.Name.Equal[turboLoot]}) /e3p off
    
    /call PauseAFollow
    
    | Some MQ builds/servers don't support /interrupt; /stopcast is widely supported.
    /stopcast
    /delay 1
/return

| ---------------------------------------------------------------------
| BEGIN LOOTING
| ---------------------------------------------------------------------
Sub BeginLooting
    /hidecorpse looted
    /echo ${tlTag} \ag[${Time}] Started Looting \at(range: ${lootDistance} ft)

    /declare corpseCount int local 0
    /declare lookupName string local
    | Final sweep (optional): one extra retry pass when everything in range becomes alerted
    /declare finalSweepDone bool local FALSE
    /declare finalSweepNeeded bool local FALSE
    /declare sweepLootDistance int local ${lootDistance}
    /if (${finalSweepRadiusFeet} > 0 && ${finalSweepRadiusFeet} < ${sweepLootDistance}) /varset sweepLootDistance ${finalSweepRadiusFeet}

:mainlootloop
    /squelch /afollow off
    
    | Check for aggressive mobs if StopLootWhenAttacked is enabled
    /if (${stopLootWhenAttacked}) {
        /if (${SpawnCount[npc radius ${lootDistance} los playerstate 4]}) {
            /echo ${tlTag} \arWARNING: STOPPING turboLoot - Aggressive mobs detected in loot area!
            /if (${AlertIndex}) /squelch /alert clear ${AlertIndex}
            /call CloseBags
            /deletevar turboLootRunning
            /varset mainLoopIterations 0
            /call Cleanup
            /return
        }
    }

    /varset corpseCount ${SpawnCount[npccorpse radius ${lootDistance}]}
    /if (!${corpseCount}) /varset corpseCount ${SpawnCount[corpse radius ${lootDistance}]}
    /if (!${corpseCount}) {
        | If we've looted something, we're probably done. Otherwise, try refreshing spawn list once
        /if (!${DidLoot}) {
            /if (${showDebug}) /echo [turboLoot] No corpses found within ${lootDistance}. Attempting spawn list refresh...
            /squelch /hidecorpse all
            /delay 1
            /squelch /hidecorpse none
            /delay 1
            /squelch /docommand #corpsefix
            /delay 1
            | Re-check after refresh (try both npccorpse and corpse)
            /varset corpseCount ${SpawnCount[npccorpse radius ${lootDistance}]}
            /if (!${corpseCount}) /varset corpseCount ${SpawnCount[corpse radius ${lootDistance}]}
            /if (${corpseCount}) {
                /if (${showDebug}) /echo [turboLoot] Spawn list refresh successful - found corpses
                /goto :mainlootloop
            }
        }
        /if (${showDebug}) /echo [turboLoot] No corpses found within ${lootDistance}. Exiting.
        /if (${Me.Grouped} && ${DidLoot}) /e3bc ${tlTag} [DONE LOOTING ${corpsesProcessed} CORPSES]
        /if (${AlertIndex}) /squelch /alert clear ${AlertIndex}
        /call CloseBags
        /deletevar turboLootRunning
        /varset mainLoopIterations 0
        /declare turboLootCooldown int global 1
        /timed 50 /deletevar turboLootCooldown
        /call Cleanup
        /return
    }
    
    /varset corpseCount ${SpawnCount[npccorpse noalert ${AlertIndex} radius ${lootDistance}]}
    /if (!${corpseCount}) /varset corpseCount ${SpawnCount[corpse noalert ${AlertIndex} radius ${lootDistance}]}
    /if (!${corpseCount}) {
        /if (${finalSweepEnabled} && ${finalSweepNeeded} && !${finalSweepDone}) {
            /varset finalSweepDone TRUE
            /if (${lootDistance} != ${sweepLootDistance}) /varset lootDistance ${sweepLootDistance}
            /if (${showDebug}) /echo [turboLoot] Final sweep: retrying corpses within ${lootDistance} ft (1 extra pass)
            /if (${AlertIndex}) /squelch /alert clear ${AlertIndex}
            /goto :mainlootloop
        }
        /if (${showDebug}) /echo [turboLoot] All corpses in range are marked as alerted.
        /if (${DidLoot}) {
            /varset corpseCount ${SpawnCount[npccorpse noalert ${AlertIndex} radius ${lootDistance}]}
            /if (!${corpseCount}) /varset corpseCount ${SpawnCount[corpse noalert ${AlertIndex} radius ${lootDistance}]}
            /if (!${corpseCount}) {
                /if (${showDebug}) /echo [turboLoot] Still no unalerted corpses after brief check. Exiting.
                /if (${Me.Grouped} && ${DidLoot}) /e3bc ${tlTag} [DONE LOOTING ${corpsesProcessed} CORPSES]
                /if (${AlertIndex}) /squelch /alert clear ${AlertIndex}
                /call CloseBags
                /deletevar turboLootRunning
                /varset mainLoopIterations 0
                /declare turboLootCooldown int global 1
                /timed 50 /deletevar turboLootCooldown
                /call Cleanup
                /return
            }
        } else {
            /if (${showDebug}) /echo [turboLoot] No unalerted corpses and nothing looted. Exiting.
            /if (${AlertIndex}) /squelch /alert clear ${AlertIndex}
            /call CloseBags
            /deletevar turboLootRunning
            /varset mainLoopIterations 0
            /declare turboLootCooldown int global 1
            /timed 50 /deletevar turboLootCooldown
            /call Cleanup
            /return
        }
    }
    
    /varcalc mainLoopIterations ${mainLoopIterations}+1
    /if (${mainLoopIterations} > ${maxMainLoopIterations}) {
        /echo [turboLoot] WARNING: Main loop exceeded ${maxMainLoopIterations} iterations. Exiting to prevent infinite loop.
        /e3p off
        /deletevar turboLootRunning
        /varset mainLoopIterations 0
        /if (${AlertIndex}) /squelch /alert clear ${AlertIndex}
        /if (${Defined[turboLootSafetyNet]}) /deletevar turboLootSafetyNet
        /declare turboLootCooldown int global 1
        /timed 50 /deletevar turboLootCooldown
        /docommand /lootnodrop ${lootNoDropPromptReset}
        /call UnpauseAFollow
        /endmac
    }

    /if (${Me.FreeInventory}) {
        /varset corpseCount ${SpawnCount[npccorpse noalert ${AlertIndex} radius ${lootDistance}]}
        /if (!${corpseCount}) /varset corpseCount ${SpawnCount[corpse noalert ${AlertIndex} radius ${lootDistance}]}
        /if (${corpseCount} > 0) {
            /if (${SpawnCount[npccorpse noalert ${AlertIndex} radius ${lootDistance}]} > 0) {
                /target npccorpse noalert ${AlertIndex} radius ${lootDistance}
            } else {
                /target corpse noalert ${AlertIndex} radius ${lootDistance}
            }
            | If targeting failed but SpawnCount says corpses exist, try refreshing spawn list once per loop iteration
            /if (!${Target.ID} || !${Target.Type.Equal[Corpse]}) {
                /declare targetingRefreshDone bool local FALSE
                /if (!${targetingRefreshDone}) {
                    /if (${showDebug}) /echo [turboLoot] Targeting failed but SpawnCount shows corpses exist - refreshing spawn list...
                    /squelch /hidecorpse all
                    /delay 1
                    /squelch /hidecorpse none
                    /delay 1
                    /squelch /docommand #corpsefix
                    /delay 1
                    /varset targetingRefreshDone TRUE
                    | Retry targeting (try both spawn types)
                    /if (${SpawnCount[npccorpse noalert ${AlertIndex} radius ${lootDistance}]} > 0) {
                        /target npccorpse noalert ${AlertIndex} radius ${lootDistance}
                    } else /if (${SpawnCount[corpse noalert ${AlertIndex} radius ${lootDistance}]} > 0) {
                        /target corpse noalert ${AlertIndex} radius ${lootDistance}
                    }
                }
            }

            /if ((${Target.ID}) && (${Target.Type.Equal[Corpse]})) {
                /if (${Target.Distance} > ${lootDistance}) {
                    /if (${showDebug}) /echo [turboLoot] Corpse ${Target.ID} is too far (${Target.Distance} > ${lootDistance}), skipping this attempt
                    /target clear
                    /goto :mainlootloop
                }
                
                | FD check before movement
                | Always resume E3Next on FD abort (macro paused E3 with /e3p on at start)
                /if (${Me.Feigning}) {
                    /if (${showDebug}) /echo [turboLoot] Went FD mid-run - exiting and resuming E3
                    /if (${Me.Grouped}) /docommand /${announceMethod} [FEIGNED] Currently FD and not looting
                    /e3p off
                    /deletevar turboLootRunning
                    /if (${Defined[turboLootSafetyNet]}) /deletevar turboLootSafetyNet
                    /docommand /lootnodrop ${lootNoDropPromptReset}
                    /call UnpauseAFollow
                    /endmac
                }
                
                /varset moveTries 0
                /face fast
                
                | Store corpse ID for validation during movement
                /varset corpseID ${Target.ID}
                
                | Try nav first (proper pathfinding), fall back to moveto if nav unavailable
                /if (${Target.Distance} > 10) {
                    /if (${Navigation.PathExists[id ${Target.ID}]}) {
                        /if (${showDebug}) /echo [turboLoot] Using /nav to reach corpse ${Target.ID} (distance: ${Target.Distance})
                        /nav id ${Target.ID} distance=10
                        | Wait for nav to complete (up to 10 seconds)
                        /delay 100 !${Navigation.Active} || ${Target.Distance} <= 10
                        /if (${Navigation.Active}) {
                            /squelch /nav stop
                        }
                    } else {
                        /if (${showDebug}) /echo [turboLoot] No nav path, using /moveto for corpse ${Target.ID}
                        /goto :moveToCorpseLoop
                    }
                }
                
                | If nav got us close enough, skip the moveto loop
                /if (${Target.Distance} <= 10) /goto :doneMoving
                
                | Fallback moveto loop for fine positioning or when nav unavailable
:moveToCorpseLoop
                | FD check during movement
                | Always resume E3Next on FD abort (macro paused E3 with /e3p on at start)
                /if (${Me.Feigning}) {
                    /if (${showDebug}) /echo [turboLoot] Went FD during movement - exiting and resuming E3
                    /if (${Me.Grouped}) /docommand /${announceMethod} [FEIGNED] Currently FD and not looting
                    /e3p off
                    /deletevar turboLootRunning
                    /if (${Defined[turboLootSafetyNet]}) /deletevar turboLootSafetyNet
                    /docommand /lootnodrop ${lootNoDropPromptReset}
                    /call UnpauseAFollow
                    /endmac
                }
                /if (${Target.Distance} <= 10) /goto :doneMoving
                
                | Verify target is still our corpse
                /if (!${Target.ID} || ${Target.ID} != ${corpseID}) {
                    /if (${showDebug}) /echo [turboLoot] Lost corpse target during movement
                    /target clear
                    /goto :mainlootloop
                }
                
                /if (${Target.Distance} >= ${lootDistance}) {
                    /if (${showDebug}) /echo [turboLoot] Corpse ${Target.ID} became too far during movement (${Target.Distance} >= ${lootDistance}), skipping this attempt
                    /target clear
                    /goto :mainlootloop
                }
                
                /varcalc moveTries ${moveTries}+1
                /if (${moveTries} > 30) {
                    /if (${showDebug}) /echo [turboLoot] Cannot reach corpse ${Target.ID} after ${moveTries} attempts
                    /echo [turboLoot] WARNING: Movement failed for corpse ${Target.ID} - ensure MQ2Nav or MQ2MoveUtils is loaded
                    /if (${Target.Distance} > 15) {
                        /if (${showDebug}) /echo [turboLoot] Corpse ${Target.ID} still too far (${Target.Distance} > 15), marking to skip
                        /varset finalSweepNeeded TRUE
                        /alert add ${AlertIndex} id ${Target.ID}
                    } else {
                        /if (${showDebug}) /echo [turboLoot] Corpse ${Target.ID} is close (${Target.Distance}) but pathing failed, will retry later
                    }
                    /target clear
                    /goto :mainlootloop
                }
                
                /face fast
                /moveto id ${Target.ID} dist 10
                /delay 5
                /goto :moveToCorpseLoop
                
:doneMoving
                | Validate corpse is still valid after movement
                /if (!${Target.ID} || !${Target.Type.Equal[Corpse]}) {
                    /if (${showDebug}) /echo [turboLoot] Corpse no longer valid after movement
                    /target clear
                    /goto :mainlootloop
                }

                | Clear cursor if needed (conditional delays - exit early when cursor is empty)
                /if (${Cursor.ID}) {
                    /autoinventory
                    /delay 5 !${Cursor.ID}
                    /if (${Cursor.ID}) {
                        /autoi
                        /delay 5 !${Cursor.ID}
                        /if (${Cursor.ID}) {
                            /autoinventory
                            /delay 5 !${Cursor.ID}
                            /if (${Cursor.ID}) {
                                /echo [turboLoot] ERROR: Item stuck on cursor after /autoinventory: ${Cursor.Name}. Clear cursor and rerun.
                                /e3p off
                                /deletevar turboLootRunning
                                /if (${AlertIndex}) /squelch /alert clear ${AlertIndex}
                                /if (${Defined[turboLootSafetyNet]}) /deletevar turboLootSafetyNet
                                /declare turboLootCooldown int global 1
                                /timed 50 /deletevar turboLootCooldown
                                /docommand /lootnodrop ${lootNoDropPromptReset}
                                /call UnpauseAFollow
                                /endmac
                            }
                        }
                    }
                }
                
                /varset modeCheck ${restoreFollowMode.Upper.Replace[ ,]}
                /if (${modeCheck.NotEqual[NONE]} && ${modeCheck.Length} && ${modeCheck.NotEqual[NULL]} && ${modeCheck.NotEqual[0]}) {
                    /call StopFollowAndMovement
                }
                /loot
                /doevents
                /varset DidLoot TRUE
                /varset DidLootThisCorpse FALSE

                /if (${Skip}) {
                    /varset Skip FALSE
                    /notify LootWnd DoneButton leftmouseup
                    /delay 1
                    /goto :mainlootloop
                }

                | Wait for loot window to open (conditional delay - exits early when window opens)
                /delay 10 ${Window[LootWnd].Open}
                /doevents
                /if (${Window[LootWnd].Open}) {
                    /varcalc corpsesProcessed ${corpsesProcessed}+1
                }
                /if (!${Window[LootWnd].Open}) {
                    | Try a small position adjustment and retry
                    /if (${showDebug}) /echo [turboLoot] Loot window failed to open for corpse ${Target.ID}, trying position adjustment...
                    /keypress forward hold
                    /delay 2
                    /keypress forward
                    /delay 1
                    /loot
                    /delay 10 ${Window[LootWnd].Open}
                    /doevents
                }
                /if (!${Window[LootWnd].Open}) {
                    /if (${showDebug}) /echo [turboLoot] Loot window still failed to open for corpse ${Target.ID} after retry, will retry later
                    /varset finalSweepNeeded TRUE
                    /target clear
                    /goto :mainlootloop
                }

                /varset loottotal ${Corpse.Items}
                /if (${loottotal}<=0) {
                    /notify LootWnd DoneButton leftmouseup
                    /delay 1
                    /goto :mainlootloop
                }

                | Ensure no-drop prompt is set correctly before processing items
                /docommand /lootnodrop ${lootNoDropPrompt}
                
                | Next chunk will process items
                /goto :processItems
            }
        }
    } else {
        /declare msg string local ${FormatMessage[\ar [turboLoot] My Inventory is full!!,${announceMethod}]}
        /docommand /${announceMethod} ${msg}
        /e3p off
        /deletevar turboLootRunning
        /varset mainLoopIterations 0
        /if (${AlertIndex}) /squelch /alert clear ${AlertIndex}
        /if (${Defined[turboLootSafetyNet]}) /deletevar turboLootSafetyNet
        /declare turboLootCooldown int global 1
        /timed 50 /deletevar turboLootCooldown
        /docommand /lootnodrop ${lootNoDropPromptReset}
        /call UnpauseAFollow
        /endmac
    }
    /goto :mainlootloop

| ---------------------------------------------------------------------
| ITEM PROCESSING LOOP
| ---------------------------------------------------------------------
:processItems
    /varset loottotal ${Corpse.Items}
    /if (${lootTribMinValue} > 0 && ${loottotal} > 0 && ${showDebug}) /echo [turboLoot] lootTribMinValue=${lootTribMinValue} active - will loot unlisted items with tribute/value >= threshold

    /for lootslot 1 to ${loottotal}
        | Process events and clear cursor before each slot (prevents "cursor occupied" errors)
        /doevents
        /if (${Cursor.ID}) /call ForceClearCursor
        /if (${LoreBlocked}) {
            /if (${showDebug}) /echo [turboLoot] Lore block detected at start of loop for slot ${lootslot}
            | Add to denied cache using last attempted item name
            /if (${LoreDeniedNames.Length} > 2000) /varset LoreDeniedNames ""
            /if (${LoreAttemptName.Length} && (!${LoreDeniedNames.Length} || !${LoreDeniedNames.Find[|${LoreAttemptName}|]})) {
                /varset LoreDeniedNames "${LoreDeniedNames}|${LoreAttemptName}|"
                /if (${showDebug}) /echo [turboLoot] Added "${LoreAttemptName}" to LoreDeniedNames cache
            }
            /varset LoreBlocked FALSE
            /varset LoreBlockedName ""
        }
        
        | Check if loot window is still open - if not, go back to main loop to re-target
        /if (!${Window[LootWnd].Open}) {
            /if (${showDebug}) /echo [turboLoot] Loot window closed unexpectedly during item processing, returning to main loop
            /goto :mainlootloop
        }
        
        /if (!${Corpse.Item[${lootslot}].ID}) /continue

        | Get item name - use explicit .Name property
        /varset lootName ${Corpse.Item[${lootslot}].Name}
        | Validate lootName immediately after retrieval
        /if (!${lootName.Length} || ${lootName.Equal[NULL]} || ${lootName.Equal[null]}) {
            /if (${showDebug}) /echo [turboLoot] ERROR: Cannot get item name for slot ${lootslot} (ID: ${Corpse.Item[${lootslot}].ID}, Name length: ${lootName.Length})
            /continue
        }
        /varset itemValue ${Math.Calc[${Corpse.Item[${lootslot}].Value} / 1000]}
        /varset tribVal ${Int[${Corpse.Item[${lootslot}].Tribute}]}
        | ItemLimits lookup: use IniGetStringOrEmpty (same as Settings - strips comments, trims)
        /varset lookupName ${TrimSpaces[${lootName}]}
        /varset itemLimit ${IniGetStringOrEmpty[ItemLimits,${lookupName}]}
        /if (!${itemLimit.Length}) /varset itemLimit ${IniGetStringOrEmpty[ItemLimits,${lookupName.Upper}]}
        /if (!${itemLimit.Length}) /varset itemLimit ${IniGetStringOrEmpty[ItemLimits,${lookupName.Lower}]}
        /if (!${itemLimit.Length}) /varset itemLimit ${IniGetStringOrEmpty[Item Limits,${lookupName}]}
        /if (${itemLimit.Length} && !${itemLimit.Equal[NULL]}) {
            /varset itemLimitUpper ${itemLimit.Upper}
            /varset itemLimitUpper ${itemLimitUpper.Replace[ ,]}
            /if (${itemLimitUpper.Equal[SKIP]}) /varset itemLimitUpper IGNORE
        } else {
            /varset itemLimit ""
            /varset itemLimitUpper ""
        }
        | Final check: clear if empty/NULL/0/NOTFOUND (like turboLoot359Final.mac does)
        | NOTFOUND: MQ2 Ini returns this when key missing and no default given
        /if (!${itemLimitUpper.Length} || ${itemLimitUpper.Equal[NULL]} || ${itemLimitUpper.Equal[0]} || ${itemLimitUpper.Equal[NOTFOUND]}) {
            /varset itemLimit ""
            /varset itemLimitUpper ""
        }
        /if (${showDebug}) /echo [DEBUG] Item ${lootName} - INI lookup returned: "${itemLimit}" -> itemLimitUpper: "${itemLimitUpper}"
        /if (${showDebug} && ${itemLimitUpper.Equal[SELL]}) /echo [DEBUG] Found SELL item: ${lootName} - itemLimit="${itemLimit}" itemLimitUpper="${itemLimitUpper}"

        | -------------------------------------------------------------
        | IGNORE
        | -------------------------------------------------------------
        /if (${itemLimitUpper.Equal[IGNORE]}) {
            /if (${showDebug}) /call Announce "${announceMethod}" "${tlTag} \aw[IGNORE] ${Corpse.Item[${lootslot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID})"
            /varcalc itemsIgnored ${itemsIgnored}+1
            /continue
        }

        | -------------------------------------------------------------
        | DESTROY
        | -------------------------------------------------------------
    /if (${itemLimitUpper.Equal[DESTROY]}) {
            | Check if this is a LORE item we already possess (inv + bank) - can't loot it to destroy it
            /if (${Corpse.Item[${lootslot}].Lore}) {
                /declare destroyLoreCount int local ${Math.Calc[${FindItemCount[=${lootName}]}+${FindItemBankCount[=${lootName}]}]}
                /if (${destroyLoreCount} >= 1) {
                    /call AnnounceSkipped "${Target.ID}:${lootslot}:${lootName}" "${tlTag} \ao[SKIP] ${Corpse.Item[${lootslot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID}) - LORE item already in inventory/bank (can't loot to destroy)"
                    /continue
                }
            }
            /if (${showDebug} || ${announceDestroyed}) /call Announce "${announceMethod}" "${tlTag} \ar[DESTROY] ${Corpse.Item[${lootslot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID})"
            /call LootAndDestroyCorpseItem ${lootslot} "${lootName}"
            /if (${Skip}) /goto :DoneLooting
            /varset DidLootThisCorpse TRUE
            /continue
        }

        | -------------------------------------------------------------
        | LORE-DENIED CACHE CHECK
        | -------------------------------------------------------------
        /if (${Corpse.Item[${lootslot}].Lore} && ${LoreDeniedNames.Find[|${lootName}|]}) {
            /call AnnounceSkipped "${Target.ID}:${lootslot}:${lootName}" "${tlTag} \ao[SKIP] ${Corpse.Item[${lootslot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID}) - Already have"
            /continue
        }

        | -------------------------------------------------------------
        | WILDCARD ITEMS (SPELL:, SKILL:, TOME, SONG:)
        | -------------------------------------------------------------
        /if (${IsWildcardItem[${lootName}]}) {
            /if (${showDebug}) /echo [DEBUG] Wildcard item detected: ${lootName} - itemLimit from INI: "${itemLimit}" upper:"${itemLimitUpper}"
        
            | If user explicitly set IGNORE, respect it
            /if (${itemLimitUpper.Equal[IGNORE]}) {
                /if (${showDebug}) /docommand /${announceMethod} ${tlTag} \aw[IGNORE] ${Corpse.Item[${lootslot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID}) \at(Wildcard)
                /varcalc itemsIgnored ${itemsIgnored}+1
                /continue
            }
        
            | Otherwise wildcard items are always looted
            /varset itemLimit ALL
            /varset itemLimitUpper WILD
            /if (${showDebug}) /echo [DEBUG] Wildcard item - forcing to ALL
        
            /call ProcessLootItem ${lootslot} "${itemLimit}"
            /if (${Skip}) /goto :DoneLooting
            /if (!${Corpse.Item[${lootslot}].ID}) /varset DidLootThisCorpse TRUE
            /continue
        }
        
        | -------------------------------------------------------------
        | HIGH-VALUE LOOTING (same logic as lootHighValueMinPP)
        | Also: lootTribMinValue - loot unlisted items with tribute/value >= threshold (no itemLimit check, like minLootValue)
        | -------------------------------------------------------------
        /varset meetsTribThreshold FALSE
        /if (${lootTribMinValue} > 0 && (${tribVal} >= ${lootTribMinValue} || (${tribVal} == 0 && ${itemValue} >= ${lootTribMinValue}))) /varset meetsTribThreshold TRUE
        /if (${showDebug} && ${lootTribMinValue} > 0) /echo [DEBUG] TRIBUTE-VALUE: ${lootName} trib=${tribVal} val=${itemValue} need=${lootTribMinValue} meets=${meetsTribThreshold}
        | Enter on high-value (minLootValue) OR tribute (lootTribMinValue) - same logic, no itemLimit gate
        /if (!${Corpse.Item[${lootslot}].Stackable} && (${enableHighValue} && (${lootHighValueAll} || (${minLootValue} > 0 && ${itemValue} >= ${minLootValue})) || (${meetsTribThreshold}))) {
            | Check lore denied cache FIRST - skip if we already failed to loot this item
            /if (${Corpse.Item[${lootslot}].Lore} && ${LoreDeniedNames.Find[|${lootName}|]}) {
                /if (${showDebug}) /echo [VALUE] Skipping ${lootName} - in LoreDeniedNames cache
                /call AnnounceSkipped "${Target.ID}:${lootslot}:${lootName}" "${tlTag} \ao[SKIP] ${Corpse.Item[${lootslot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID}) - Already have (cached)"
                /continue
            }
            /if (${itemLimitUpper.Equal[IGNORE]}) {
                /if (${showDebug}) /call Announce "${announceMethod}" "${tlTag} \aw[IGNORE] ${Corpse.Item[${lootslot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID}) - High value but IGNORE"
                /varcalc itemsIgnored ${itemsIgnored}+1
                /continue
            }
            | If item is marked SELL/KEEP/BANK/TRIBUTE, use ProcessLootItem instead of high-value path
            | This ensures proper handling and announcements for these items
            /if (${itemLimitUpper.Equal[SELL]} || ${itemLimitUpper.Equal[KEEP]} || ${itemLimitUpper.Equal[BANK]} || ${itemLimitUpper.Equal[TRIBUTE]}) {
                /if (${showDebug}) /echo [VALUE] High-value item ${lootName} is marked ${itemLimitUpper}, using ProcessLootItem instead of high-value path
                /call ProcessLootItem ${lootslot} "${itemLimit}"
                /if (${Skip}) /goto :DoneLooting
                /if (!${Corpse.Item[${lootslot}].ID}) /varset DidLootThisCorpse TRUE
                /continue
            }
            /if (${Corpse.Item[${lootslot}].Lore}) {
                /varset currentCount ${Math.Calc[${FindItemCount[=${lootName}]}+${FindItemBankCount[=${lootName}]}]}
                /if (${currentCount}>=1) {
                    /call AnnounceSkipped "${Target.ID}:${lootslot}:${lootName}" "${tlTag} \ao[SKIP] ${Corpse.Item[${lootslot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID}) - Already have"
                    /continue
                }
            }
            | Tribute path (lootTribMinValue): unlisted items meeting threshold - same as minLootValue logic
            /if (${meetsTribThreshold} && !${itemLimitUpper.Length}) {
                /call Announce "${announceMethod}" "${tlTag} \ag[TRIB-LOOT] ${Corpse.Item[${lootslot}].ItemLink[CLICKABLE]} \at(${If[${tribVal},tribute: ${tribVal},value: ${itemValue}pp]})"
                /call CheckInventorySpace "${lootName}" ${lootslot}
                /call LootTheItem ${lootslot} "${lootName}" 999999 "TRIBUTE"
            } else {
                /if (${showDebug}) /echo [VALUE] Found valuable item worth ${itemValue} platinum
                /call LootHighValueItem ${lootslot}
            }
            /if (${Skip}) /goto :DoneLooting
            /if (!${Corpse.Item[${lootslot}].ID}) /varset DidLootThisCorpse TRUE
            /continue
        }

        | -------------------------------------------------------------
        | STACKABLE LOOTING (enter when lootStackable OR stackable tribute item meets threshold)
        | -------------------------------------------------------------
        /if (${Corpse.Item[${lootslot}].Stackable} && (${lootStackable} || ${meetsTribThreshold})) {
            | Check lore denied cache FIRST - skip if we already failed to loot this item
            /if (${Corpse.Item[${lootslot}].Lore} && ${LoreDeniedNames.Find[|${lootName}|]}) {
                /if (${showDebug}) /echo [STACK] Skipping ${lootName} - in LoreDeniedNames cache
                /call AnnounceSkipped "${Target.ID}:${lootslot}:${lootName}" "${tlTag} \ao[SKIP] ${Corpse.Item[${lootslot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID}) - Already have (cached)"
                /continue
            }
            /if (${itemLimitUpper.Equal[IGNORE]}) {
                /if (${showDebug}) /call Announce "${announceMethod}" "${tlTag} \aw[IGNORE] ${Corpse.Item[${lootslot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID}) - Stackable but IGNORE"
                /varcalc itemsIgnored ${itemsIgnored}+1
                /continue
            }
            | Process ALL, numeric limits, SELL, KEEP, BANK, and TRIBUTE items
            /if (${itemLimit.Length} && (${itemLimitUpper.Equal[ALL]} || ${itemLimitUpper.Equal[SELL]} || ${itemLimitUpper.Equal[KEEP]} || ${itemLimitUpper.Equal[BANK]} || ${itemLimitUpper.Equal[TRIBUTE]} || (${Int[${itemLimit}]} > 0))) {
                /if (${showDebug}) /echo [STACK] Listed stackable item ${lootName} has limit "${itemLimit}" - enforcing via ProcessLootItem
                /call ProcessLootItem ${lootslot} "${itemLimit}"
            } else {
                | Unlisted stackable: skip if below pp threshold (unless meetsTribThreshold). If lootStackable=0, only loot when meetsTribThreshold.
                /if (!${meetsTribThreshold} && (!${lootStackable} || (${minStackableValue} > 0 && ${itemValue} < ${minStackableValue}))) {
                    /if (${showDebug}) /echo [STACK] Unlisted stackable ${lootName} worth ${itemValue}pp (tribute: ${tribVal}) below threshold - skipping
                    /call AnnounceSkipped "${Target.ID}:${lootslot}:${lootName}" "${tlTag} \ao[SKIP] ${Corpse.Item[${lootslot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID}) - Below ${minStackableValue}pp threshold"
                    /continue
                }
                /if (${showDebug}) /echo [STACK] Unlisted stackable item ${lootName} worth ${itemValue}pp ${If[${meetsTribThreshold},(tribute),- looting due to LootStackable]}
                /call CheckInventorySpace "${lootName}" ${lootslot}
                | Pass STACK for unlisted so LootTheItem gets non-empty limitParam (empty can skip announcement on some MQ2 builds)
                /call LootTheItem ${lootslot} "${lootName}" 999999 "${If[${meetsTribThreshold},TRIBUTE,${If[${itemLimit.Length},${itemLimit},STACK]}]}"
            }
            /if (${Skip}) /goto :DoneLooting
            /if (!${Corpse.Item[${lootslot}].ID}) /varset DidLootThisCorpse TRUE
            /continue
        }

        | -------------------------------------------------------------
        | NORMAL LOOTING (INI-driven)
        | -------------------------------------------------------------
        | LORE precheck: Skip LORE items we already own (ProcessLootItem will also check, but this avoids unnecessary calls)
        /if (${Corpse.Item[${lootslot}].Lore}) {
            /varset currentCount ${Math.Calc[${FindItemCount[=${lootName}]}+${FindItemBankCount[=${lootName}]}]}
            /if (${showDebug}) /echo [turboLoot] LORE precheck: "${lootName}" inv=${FindItemCount[=${lootName}]} bank=${FindItemBankCount[=${lootName}]} total=${currentCount}
            /if (${currentCount}>=1) {
                /call AnnounceSkipped "${Target.ID}:${lootslot}:${lootName}" "${tlTag} \ao[SKIP] ${Corpse.Item[${lootslot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID}) - Already have"
                /continue
            }
        }

        | Process ALL, numeric limits, SELL, KEEP, BANK, and TRIBUTE items
        /if (${showDebug} && ${itemLimitUpper.Equal[SELL]}) /echo [DEBUG] Checking SELL item ${lootName} - itemLimitUpper="${itemLimitUpper}" - condition check
        /if (${itemLimit.Length} && (${itemLimitUpper.Equal[ALL]} || ${itemLimitUpper.Equal[SELL]} || ${itemLimitUpper.Equal[KEEP]} || ${itemLimitUpper.Equal[BANK]} || ${itemLimitUpper.Equal[TRIBUTE]} || (${Int[${itemLimit}]} > 0))) {
            /if (${showDebug} && ${itemLimitUpper.Equal[SELL]}) /echo [DEBUG] SELL item ${lootName} passed condition check, calling ProcessLootItem
            /call ProcessLootItem ${lootslot} "${itemLimit}"
            /if (${Skip}) /goto :DoneLooting
            /if (!${Corpse.Item[${lootslot}].ID}) /varset DidLootThisCorpse TRUE
        } else {
            | Item is unlisted - skip (tribute handled by TRIBUTE-VALUE section above)
            /if (${showDebug}) /echo [DEBUG] Item ${lootName} is unlisted (tribute: ${tribVal}, need >=${lootTribMinValue}) - skipping
            /call AnnounceSkipped "${Target.ID}:${lootslot}:${lootName}" "${tlTag} \ao[SKIP] ${Corpse.Item[${lootslot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID}) \at(tribute: ${tribVal}, need >=${lootTribMinValue})"
        }

    /next lootslot

:DoneLooting
    /if (!${DidLootThisCorpse} && !${Skip}) {
        /if (${Corpse.Items} <= 0) {
            /if (${showDebug}) /echo [turboLoot] Corpse ${Target.ID} is empty, marking to skip
            /alert add ${AlertIndex} id ${Target.ID}
        } else {
            /if (${showDebug}) /echo [turboLoot] No items looted from corpse ${Target.ID} but corpse still has items (all skipped by limits), will retry later
        }
    }
    /varset Skip FALSE
    /varset LoreBlocked FALSE
    /varset LoreBlockedName ""
    /varset closeTries 0
:CloseLootWindow
    /varcalc closeTries ${closeTries}+1
    /if (${closeTries} > 10) {
        /if (${showDebug}) /echo [turboLoot] Loot window stuck open after ${closeTries} attempts, forcing close
        /call TryCloseLootWindow
        /delay 1
        /if (${Window[LootWnd].Open}) {
            /echo [turboLoot] ERROR: Loot window still open. Aborting to prevent hang.
            /call Cleanup
            /endmac
        }
        /goto :mainlootloop
    }
    /call TryCloseLootWindow
    /delay 1

    /doevents
    /if (${Window[LootWnd].Open}) /goto :CloseLootWindow

    /if (!${Me.FreeInventory}) {
        /if (${Me.Grouped} && ${DidLoot}) /e3bc ${tlTag} [DONE LOOTING ${corpsesProcessed} CORPSES]
        /if (${showDebug}) /echo [turboLoot] No more lootable corpses found. Exiting.
        /if (${AlertIndex}) /squelch /alert clear ${AlertIndex}
        /call CloseBags
        /deletevar turboLootRunning
        /varset mainLoopIterations 0
        /if (${Defined[turboLootSafetyNet]}) /deletevar turboLootSafetyNet
        /declare turboLootCooldown int global 1
        /timed 50 /deletevar turboLootCooldown
        /call Cleanup
        /return
    }
    /goto :mainlootloop
/return

|| ---------------------------------------------------------------------
|| AUTO SELL
|| ---------------------------------------------------------------------
Sub AutoSell
    | Use outer variables (declared in InitState) - no local declares needed
    
    /varset itemsSold 0
    /varset platinumGain 0
    /varset sellTotalCopper 0
    
    | Local variables for tracking
    /declare totalItemsChecked int local 0
    /declare itemsWithIniEntry int local 0
    | Declare itemLink and iniColor once for the entire subroutine (used in both main inventory and bag loops)
    /declare itemLink string local
    /declare iniColor string local
    
    /call AnnounceBankSell "${tlTag} \au======================================================="
    /call AnnounceBankSell "${tlTag} \aoStarting turboSell process..."

    | Drop levitation before navigating - lev interferes with MQ2Nav pathing
    /if (${Me.Levitating}) {
        /call AnnounceBankSellProgress "${tlTag} \ayDetected levitation - removing before navigating..."
        /removelev
        /delay 10 !${Me.Levitating}
        /if (${Me.Levitating}) /call AnnounceBankSell "${tlTag} \aoWARNING: Could not remove levitation. This may cause navigation issues."
    }

    | Clear any existing target to ensure we find the nearest merchant
    | This prevents issues when user has a non-merchant NPC or other entity targeted
    /target clear
    /delay 1
    
    | Check if merchant window is open, if not try to find and open one
    /if (!${Window[MerchantWnd].Open}) {
        /call AnnounceBankSellProgress "${tlTag} \ayMerchant window not open - attempting to find and open merchant..."
        
        | Check if merchant is already targeted first (fast path - only try opening if close enough)
        | Exclude players (PC) and self to prevent issues
        /if (${Target.ID} && ${Target.ID} != ${Me.ID} && ${Target.Type.NotEqual[PC]} && (${Target.Type.Equal[Merchant]} || ${Target.Type.Equal[NPC]})) {
            | Merchant is targeted - only try opening window if close enough (avoid delay when far away)
            /if (${Target.Distance} <= 10) {
                /invoke ${Merchant.OpenWindow}
                /delay 100 ${Window[MerchantWnd].Open}
                /doevents
            }
        }
        
        | If still not open, try targeting nearest merchant first
        /if (!${Window[MerchantWnd].Open}) {
            | Try multiple methods to find merchant
            | Method 1: Check if merchant is already targeted (accept NPC type too, as manual targeting might not show "Merchant" type)
            | Retarget if: no target, target is self, target is PC, or target is not Merchant/NPC
            /if (!${Target.ID} || ${Target.ID} == ${Me.ID} || ${Target.Type.Equal[PC]} || (${Target.Type.NotEqual[Merchant]} && ${Target.Type.NotEqual[NPC]})) {
                | Method 2: Target nearest NPC merchant using spawn search
                /target npc merchant
                /delay 1
            }
            
            | If still no merchant, try broader search
            /if (!${Target.ID} || ${Target.ID} == ${Me.ID} || ${Target.Type.Equal[PC]} || (${Target.Type.NotEqual[Merchant]} && ${Target.Type.NotEqual[NPC]})) {
                | Method 3: Use SpawnCount to find merchants
                /if (${SpawnCount[npc merchant radius 200]} > 0) {
                    /target npc merchant radius 200
                    /delay 1
                }
            }
            
            | Accept target if it's a merchant OR an NPC (manual targeting might show NPC type)
            | Exclude players (PC) and self to prevent issues
            /if (${Target.ID} && ${Target.ID} != ${Me.ID} && ${Target.Type.NotEqual[PC]} && (${Target.Type.Equal[Merchant]} || ${Target.Type.Equal[NPC]})) {
                /call AnnounceBankSellProgress "${tlTag} \ayFound merchant: \aw${Target.CleanName} \ay(distance: \aw${Target.Distance}\ay; type: \aw${Target.Type}\ay)"
                
                | Navigate to merchant if too far away
                /if (${Target.Distance} > 10) {
                    /call AnnounceBankSellProgress "${tlTag} \ayNavigating to merchant (distance: \aw${Target.Distance} \ayunits)..."
                    /face fast
                    
                    | Try nav first (proper pathfinding), fall back to moveto if unavailable
                    /declare navTries int local 0
                    /declare merchantID int local ${Target.ID}
                    /declare usedNav bool local FALSE
                    
                    /if (${Navigation.PathExists[id ${Target.ID}]}) {
                        /if (${showDebug}) /echo [turboLoot] Using /nav to reach merchant
                        /nav id ${Target.ID} distance=10
                        | Wait for nav to complete (up to 15 seconds)
                        /delay 150 !${Navigation.Active} || ${Target.Distance} <= 10
                        /if (${Navigation.Active}) {
                            /squelch /nav stop
                        }
                        /varset usedNav TRUE
                    }
                    
                    | If nav got us close enough, skip the moveto loop
                    /if (${Target.Distance} <= 10) /goto :reachedMerchant
                    
                    | Fallback moveto loop
                    :moveToMerchant
                    /if (${Target.Distance} <= 10) /goto :reachedMerchant
                    
                    | Check if target is still valid
                    /if (!${Target.ID} || ${Target.ID} != ${merchantID}) {
                        /call AnnounceBankSell "${tlTag} \arERROR: Lost merchant target during navigation"
                        /return
                    }
                    
                    /varcalc navTries ${navTries} + 1
                    /if (${navTries} > 50) {
                        /call AnnounceBankSell "${tlTag} \aoWARNING: Could not reach merchant after \aw${navTries} \aoattempts (distance: \aw${Target.Distance}\ao)"
                        /call AnnounceBankSellProgress "${tlTag} \ayAttempting to open window anyway..."
                        /goto :reachedMerchant
                    }
                    
                    /face fast
                    /moveto id ${Target.ID} dist 10
                    /delay 5
                    /doevents
                    /goto :moveToMerchant
                    
                    :reachedMerchant
                    /if (${Target.Distance} <= 10) {
                        /call AnnounceBankSellProgress "${tlTag} \agReached merchant (distance: \aw${Target.Distance}\ag)"
                    } else {
                        /call AnnounceBankSell "${tlTag} \aoWARNING: Could not fully reach merchant (distance: \aw${Target.Distance}\ao) - attempting to open window anyway"
                    }
                }
                
                | Face merchant and open window
                /face fast
                /delay 1
                
                | Try opening merchant window now that we have a target (and are close)
                /invoke ${Merchant.OpenWindow}
                
                | Wait for window to open (conditional delay - exits early when window opens, like banking)
                /delay 100 ${Window[MerchantWnd].Open}
                /doevents
                
                /if (${Window[MerchantWnd].Open}) {
                    /call AnnounceBankSellProgress "${tlTag} \agMerchant window opened: \aw${Target.CleanName}"
                } else {
                    /call AnnounceBankSell "${tlTag} \arERROR: Failed to open merchant window"
                    /call AnnounceBankSell "${tlTag} \awPlease manually target a merchant and open their window - then try again"
                    /return
                }
            } else {
                /call AnnounceBankSell "${tlTag} \arERROR: No merchant found nearby"
                /call AnnounceBankSell "${tlTag} \awPlease manually target a merchant and open their window - then try again"
                /return
            }
        } else {
            /call AnnounceBankSellProgress "${tlTag} \agMerchant window opened successfully"
        }
    }
    
    | Scan all inventory (main slots + bags)
    /call AnnounceBankSellProgress "${tlTag} \ayScanning inventory for items marked SELL..."
    
    | First scan main inventory slots (23-32 = slots 1-10 outside bags)
    | Note: Some servers have 10 inventory slots, not 8
    /call AnnounceBankSellProgress "${tlTag} \ayScanning main inventory slots (23-32)..."
    /for slotNum 23 to 32
        | Process events to keep macro responsive
        /doevents
        
        | Check if merchant window is still open (periodic check)
        /if (!${Window[MerchantWnd].Open}) {
            /call AnnounceBankSell "${tlTag} \arERROR: Merchant window closed during scan!"
            /return
        }
        
        | Check if slot has an item (check ID first, then name)
        /if (!${Me.Inventory[${slotNum}].ID}) /continue
        
        | Get item name directly (main inventory slots use direct slot access)
        | Use .Name explicitly to ensure we get the full item name
        /varset itemName ${Me.Inventory[${slotNum}].Name}
        | Set itemLink and iniColor for this loop iteration (variables already declared at start of subroutine)
        /varset itemLink ${Me.Inventory[${slotNum}].ItemLink[CLICKABLE]}
        /varset iniColor \aw
        
        | Debug output for main inventory items (only if showDebug is enabled)
        /if (${showDebug} && ${itemName.Length} && !${itemName.Equal[NULL]}) {
            /call AnnounceBankSell "${tlTag} \ayMain inventory slot ${slotNum}: ${itemLink} (ID: ${Me.Inventory[${slotNum}].ID})"
        } else /if (${showDebug} && (!${itemName.Length} || ${itemName.Equal[NULL]})) {
            /call AnnounceBankSell "${tlTag} \arWARNING: Slot ${slotNum} has item ID ${Me.Inventory[${slotNum}].ID} but name retrieval failed!"
        }

        /if (!${itemName.Length} || ${itemName.Equal[NULL]}) /continue
        
        | Check [ItemLimits] for this item (direct INI lookup with case-insensitive fallback)
        /varcalc totalItemsChecked ${totalItemsChecked} + 1
        /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName}]}
        /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
            /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Upper}]}
        }
        /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
            /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Lower}]}
        }
        /varset itemLimitUpper ${itemLimit.Upper}
        /varset itemLimitUpper ${itemLimitUpper.Replace[ ,]}
        /if (${itemLimitUpper.Equal[SKIP]}) /varset itemLimitUpper IGNORE
        | Determine color for INI value based on type (reuse iniColor already declared)
        /varset iniColor \aw
        /if (${itemLimitUpper.Equal[KEEP]}) /varset iniColor \ag
        /if (${itemLimitUpper.Equal[ALL]}) /varset iniColor \at
        /if (${itemLimitUpper.Equal[DESTROY]}) /varset iniColor \ar
        /if (${itemLimitUpper.Equal[IGNORE]}) /varset iniColor \ao
        /if (${itemLimitUpper.Equal[SELL]}) /varset iniColor \ag
        /if (${itemLimitUpper.Equal[BANK]}) /varset iniColor \ag
        | Check if it's a number (value limit) - only check numeric if not already set to a keyword
        /if (${iniColor.Equal[\aw]} && ${itemLimit.Length} && ${itemLimit.NotEqual[NULL]} && ${itemLimit.NotEqual[0]}) {
            | Try to convert to int - if it succeeds and is in valid range, it's a number
            /if (${Int[${itemLimit}]} > 0 && ${Int[${itemLimit}]} < 10000) /varset iniColor \ay
        }
        | Debug output for INI lookup (only if showDebug is enabled)
        /if (${showDebug}) {
            /call AnnounceBankSell "${tlTag} \aySlot ${slotNum} (${itemLink}) - INI lookup: \"${iniColor}${itemLimit}\ay\" (upper: \"${iniColor}${itemLimitUpper}\ay\")"
        }
        
        | Track items with INI entries for debugging
        /if (${itemLimit.Length} && !${itemLimit.Equal[NULL]}) {
            /varcalc itemsWithIniEntry ${itemsWithIniEntry} + 1
        }
        
            | Priority 1: SELL - always sell
        /if (${itemLimitUpper.Equal[SELL]}) {
            | Use bagNum=0 to indicate main inventory, pass actual slot number (23-32)
            | Note: SellItem will skip main inventory items (MQ2 limitation) and show a helpful message
            /call SellItem 0 ${slotNum} "${itemName}"
            /continue
        }
        
        | Check for BANK items in main inventory (show notice even though we can't bank them)
        /if (${itemLimitUpper.Equal[BANK]}) {
            /call AnnounceBankSell "${tlTag} \aoNOTICE: Item ${itemLink} \aoin main inventory slot ${slotNum} is marked \agBANK\ao."
            /call AnnounceBankSell "${tlTag} \arACTION REQUIRED: Move ${itemLink} \arto a bag (pack1-pack10); then run \ag/mac turboloot bank\ar to bank it. This is a limitation of MQ."
            /continue
        }
        
        | Priority 2: KEEP, ALL, or numeric - never sell (keep in inventory unless explicitly SELL/BANK/TRIBUTE)
        /if (${itemLimitUpper.Equal[KEEP]} || ${itemLimitUpper.Equal[ALL]} || (${Int[${itemLimit}]} > 0)) {
            /if (${showDebug}) {
                /echo \ag[AutoSell]\ag Skipping ${itemLink}\ag - marked as \agKEEP\aw/\agALL\aw/\ay#\aw
            }
            /continue
        }
        
        | Priority 3: IGNORE - never sell (same as KEEP for selling)
        /if (${itemLimitUpper.Equal[IGNORE]}) {
            /if (${showDebug}) {
                /echo \ag[AutoSell]\ao Skipping ${itemLink}\ao - marked as \aoIGNORE
            }
            /continue
        }

        | Priority 4: Wildcard auto-sell (optional)
        | - ON: auto-sell wildcards unless explicitly protected via KEEP/ALL/#/IGNORE/BANK/TRIBUTE
        | - OFF: never auto-sell wildcards (but explicit Item=SELL still sells)
        /if (${sellWildcards} && ${IsWildcardItem[${itemName}]}) {
            /if (${itemLimitUpper.Equal[KEEP]} || ${itemLimitUpper.Equal[ALL]} || ${itemLimitUpper.Equal[IGNORE]} || ${itemLimitUpper.Equal[BANK]} || ${itemLimitUpper.Equal[TRIBUTE]} || (${Int[${itemLimit}]} > 0)) {
                /continue
            }
            /call SellItem 0 ${slotNum} "${itemName}"
            /continue
        }
        
        | Priority 5: Sell unlisted stackables (optional)
        | Behavior: sell any unlisted stackable item with vendor value (if SellUnlistedStackable=ON)
        /if (${enableSellStackable} && ${Me.Inventory[${slotNum}].Stackable} && (!${IsWildcardItem[${itemName}]} || ${sellWildcards})) {
            | Check if item is truly unlisted (no INI entry or empty/NULL)
            /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
                | Item is unlisted - check if it has vendor value
                /if (${Me.Inventory[${slotNum}].Value} > 0) {
                    | Double-check it's not marked as KEEP/ALL/numeric
                    /if (${itemLimitUpper.NotEqual[KEEP]} && ${itemLimitUpper.NotEqual[ALL]} && ${Int[${itemLimit}]} <= 0) {
                        /varset itemValue ${Int[${Math.Calc[${Me.Inventory[${slotNum}].Value} / 1000]}]}
                        /call AnnounceBankSell "${tlTag} \ag*** Turboselling unlisted stackable ${itemLink} \ag(value: \aw${itemValue}pp\ag) ***"
                        | Use bagNum=0 to indicate main inventory, pass actual slot number (23-32)
                        /call SellItem 0 ${slotNum} "${itemName}"
                        /continue
                    }
                }
            }
        }

        | Priority 6: Sell ANY unlisted item (not just stackables)
        | Behavior: sell any unlisted item that has vendor value (if sellUnlistedItems=ON)
        /if (${enableSellUnlistedValue} && (!${IsWildcardItem[${itemName}]} || ${sellWildcards})) {
            | Check if item is truly unlisted (no INI entry or empty/NULL)
            /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
                | Item is unlisted - check if it has vendor value
                /if (${Me.Inventory[${slotNum}].Value} > 0) {
                    | Double-check it's not marked as KEEP/ALL/numeric
                    /if (${itemLimitUpper.NotEqual[KEEP]} && ${itemLimitUpper.NotEqual[ALL]} && ${Int[${itemLimit}]} <= 0) {
                        /varset itemValue ${Int[${Math.Calc[${Me.Inventory[${slotNum}].Value} / 1000]}]}
                        /call AnnounceBankSell "${tlTag} \ag*** turboSelling unlisted item ${itemLink} \ag(value: \aw${itemValue}pp\ag) ***"
                        | Use bagNum=0 to indicate main inventory, pass actual slot number (23-32)
                        /call SellItem 0 ${slotNum} "${itemName}"
                        /continue
                    }
                }
            }
        }
    /next slotNum
    
    /if (${showDebug}) /echo [turboLoot] DBG(progress) ${tlTag} \ayFinished scanning main inventory slots - now scanning bags...
    
    | Now scan all inventory bags
    /for packNum 1 to 10
        | Check if merchant window is still open (periodic check)
        /if (!${Window[MerchantWnd].Open}) {
            /call AnnounceBankSell "${tlTag} \arERROR: Merchant window closed during scan!"
            /return
        }
        
        | Check if pack exists first - check Container property (0 means pack doesn't exist or isn't a container)
        /varset maxSlots ${Me.Inventory[pack${packNum}].Container}
        /if (${maxSlots} == 0) /continue
        
        /for slotNum 1 to ${maxSlots}
            | Process events to keep macro responsive
            /doevents
            
            | Get item name directly
            /varset itemName ${Me.Inventory[pack${packNum}].Item[${slotNum}].Name}
            /if (!${itemName.Length} || ${itemName.Equal[NULL]}) /continue
            
            | Check [ItemLimits] for this item (direct INI lookup with case-insensitive fallback)
            /varcalc totalItemsChecked ${totalItemsChecked} + 1
            /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName}]}
            /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
                /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Upper}]}
            }
            /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
                /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Lower}]}
            }
            | Safety check: ensure itemLimit is initialized before string operations
            /if (!${itemLimit.Length}) /varset itemLimit ""
            /varset itemLimitUpper ${itemLimit.Upper}
            /varset itemLimitUpper ${itemLimitUpper.Replace[ ,]}
            /if (${itemLimitUpper.Equal[SKIP]}) /varset itemLimitUpper IGNORE
            | Set itemLink and iniColor for this bag slot iteration (variables already declared at start of subroutine)
            /varset itemLink ${Me.Inventory[pack${packNum}].Item[${slotNum}].ItemLink[CLICKABLE]}
            /varset iniColor \aw
            
            | Track items with INI entries for debugging
            /if (${itemLimit.Length} && !${itemLimit.Equal[NULL]}) {
                /varcalc itemsWithIniEntry ${itemsWithIniEntry} + 1
            }
            
            | Priority 1: SELL - always sell
            /if (${itemLimitUpper.Equal[SELL]}) {
                /call SellItem ${packNum} ${slotNum} "${itemName}"
                /continue
            }
            
            | Priority 2: KEEP, ALL, or numeric - never sell (keep in inventory unless explicitly SELL/BANK/TRIBUTE)
            /if (${itemLimitUpper.Equal[KEEP]} || ${itemLimitUpper.Equal[ALL]} || (${Int[${itemLimit}]} > 0)) {
                /if (${showDebug}) {
                    /echo \ag[AutoSell]\ag Skipping ${itemLink}\ag - marked as \agKEEP\aw/\agALL\aw/\ay#\aw
                }
                /continue
            }
            
            | Priority 3: IGNORE - never sell (same as KEEP for selling)
            /if (${itemLimitUpper.Equal[IGNORE]}) {
                /if (${showDebug}) {
                    /echo \ag[AutoSell]\ao Skipping ${itemLink}\ao - marked as \aoIGNORE
                }
                /continue
            }

            | Priority 4: Wildcard auto-sell (optional)
            | - ON: auto-sell wildcards unless explicitly protected via KEEP/ALL/#/IGNORE/BANK/TRIBUTE
            | - OFF: never auto-sell wildcards (but explicit Item=SELL still sells)
            /if (${sellWildcards} && ${IsWildcardItem[${itemName}]}) {
                /if (${itemLimitUpper.Equal[KEEP]} || ${itemLimitUpper.Equal[ALL]} || ${itemLimitUpper.Equal[IGNORE]} || ${itemLimitUpper.Equal[BANK]} || ${itemLimitUpper.Equal[TRIBUTE]} || (${Int[${itemLimit}]} > 0)) {
                    /continue
                }
                /call SellItem ${packNum} ${slotNum} "${itemName}"
                /continue
            }
            
            | Priority 5: Sell unlisted stackables (optional)
            | Behavior: sell any unlisted stackable item with vendor value (if SellUnlistedStackable=ON)
            /if (${enableSellStackable} && ${Me.Inventory[pack${packNum}].Item[${slotNum}].Stackable} && (!${IsWildcardItem[${itemName}]} || ${sellWildcards})) {
                | Check if item is truly unlisted (no INI entry or empty/NULL)
                /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
                    | Item is unlisted - check if it has vendor value
                    /if (${Me.Inventory[pack${packNum}].Item[${slotNum}].Value} > 0) {
                        | Double-check it's not marked as KEEP/ALL/numeric (shouldn't happen if unlisted, but safety check)
                        /if (${itemLimitUpper.NotEqual[KEEP]} && ${itemLimitUpper.NotEqual[ALL]} && ${Int[${itemLimit}]} <= 0) {
                            /varset itemValue ${Int[${Math.Calc[${Me.Inventory[pack${packNum}].Item[${slotNum}].Value} / 1000]}]}
                            /call AnnounceBankSell "${tlTag} \ag*** turboSelling unlisted stackable ${itemLink} \ag(value: \aw${itemValue}pp\ag) ***"
                            /call SellItem ${packNum} ${slotNum} "${itemName}"
                            /continue
                        }
                    }
                }
            }

            | Priority 6: Sell ANY unlisted item (not just stackables)
            | Behavior: sell any unlisted item that has vendor value (if sellUnlistedItems=ON)
            /if (${enableSellUnlistedValue} && (!${IsWildcardItem[${itemName}]} || ${sellWildcards})) {
                | Check if item is truly unlisted (no INI entry or empty/NULL)
                /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
                    | Item is unlisted - check if it has vendor value
                    /if (${Me.Inventory[pack${packNum}].Item[${slotNum}].Value} > 0) {
                        | Double-check it's not marked as KEEP/ALL/numeric
                        /if (${itemLimitUpper.NotEqual[KEEP]} && ${itemLimitUpper.NotEqual[ALL]} && ${Int[${itemLimit}]} <= 0) {
                            /varset itemValue ${Int[${Math.Calc[${Me.Inventory[pack${packNum}].Item[${slotNum}].Value} / 1000]}]}
                            /call AnnounceBankSell "${tlTag} \ag*** turboSelling unlisted item ${itemLink} \ag(value: \aw${itemValue}pp\ag) ***"
                            /call SellItem ${packNum} ${slotNum} "${itemName}"
                            /continue
                        }
                    }
                }
            }
            
        /next slotNum
    /next packNum
    
    | Build a nice currency breakdown from sellTotalCopper
    /declare soldPP int local ${Int[${Math.Calc[${sellTotalCopper}/1000]}]}
    /declare soldGP int local ${Int[${Math.Calc[(${sellTotalCopper}%1000)/100]}]}
    /declare soldSP int local ${Int[${Math.Calc[(${sellTotalCopper}%100)/10]}]}
    /declare soldCP int local ${Int[${Math.Calc[${sellTotalCopper}%10]}]}

    /if (${itemsSold} > 0) {
        /call AnnounceBankSell "${tlTag} \agturboSell complete. \awItems sold: \ag${itemsSold}\aw - Total value: \ag${soldPP}pp ${soldGP}gp ${soldSP}sp ${soldCP}cp"
    } else {
        /call AnnounceBankSell "${tlTag} \aoNo items were sold."
        /call AnnounceBankSell "${tlTag} \awCheck your \ayturboLoot.ini \aw[ItemLimits] section."
        /call AnnounceBankSell "${tlTag} \awItems must be marked \agSELL \aw(e.g. \ayItemName=SELL\aw) to be sold."
    }

    /call AnnounceBankSellProgress "${tlTag} \ayClosing merchant window when the windows and bags are closed..."
    /call CloseBags

    | Close merchant window when done
    /if (${Window[MerchantWnd].Open}) {
        /notify MerchantWnd MW_Done_Button leftmouseup
        /delay 10 !${Window[MerchantWnd].Open}
    }
    /call AnnounceBankSellProgress "${tlTag} \ayClosed merchant window."
/return

||| ---------------------------------------------------------------------
||| AUTO SELL DRY RUN (preview what would be sold)
||| ---------------------------------------------------------------------
Sub AutoSellDryRun(bool skipSummary)
    | skipSummary: if TRUE, don't print summary; if FALSE, print summary (always FALSE when called via /mac turboloot sell dryrun or report)
    | Reset dry-run counters
    /varset dryRunSellCount 0
    /varset dryRunSellTotalCopper 0
    
    | Local variables for tracking (same as AutoSell)
    /declare totalItemsChecked int local 0
    /declare itemsWithIniEntry int local 0
    /declare itemLink string local
    /declare iniColor string local
    | Note: itemName, itemLimit, itemLimitUpper, itemValue are outer variables (declared in InitStateMinimal)
    
    /call AnnounceBankSell "${tlTag} \au======================================================="
    /call AnnounceBankSell "${tlTag} \aoDRY RUN MODE - No items will be sold"
    /call AnnounceBankSell "${tlTag} \au======================================================="
    /call AnnounceBankSell "${tlTag} \ao=== ITEMS THAT WOULD BE SOLD ==="
    
    | First scan main inventory slots (23-32) - same as AutoSell
    /for slotNum 23 to 32
        | Process events to keep macro responsive
        /doevents
        
        | Note: No merchant window check needed for dry-run (we're not actually selling)
        
        | Check if slot has an item (check ID first, then name) - same as AutoSell
        /if (!${Me.Inventory[${slotNum}].ID}) /continue
        
        | Get item name directly (main inventory slots use direct slot access) - same as AutoSell
        | Use .Name explicitly to ensure we get the full item name
        /varset itemName ${Me.Inventory[${slotNum}].Name}
        | Set itemLink and iniColor for this loop iteration (variables already declared at start of subroutine)
        /varset itemLink ${Me.Inventory[${slotNum}].ItemLink[CLICKABLE]}
        /varset iniColor \aw
        
        /if (!${itemName.Length} || ${itemName.Equal[NULL]}) /continue
        
        | Check [ItemLimits] for this item (direct INI lookup with case-insensitive fallback) - same as AutoSell
        /varcalc totalItemsChecked ${totalItemsChecked} + 1
        /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName}]}
        /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
            /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Upper}]}
        }
        /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
            /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Lower}]}
        }
        /varset itemLimitUpper ${itemLimit.Upper}
        /varset itemLimitUpper ${itemLimitUpper.Replace[ ,]}
        /if (${itemLimitUpper.Equal[SKIP]}) /varset itemLimitUpper IGNORE
        
        | Track items with INI entries for debugging
        /if (${itemLimit.Length} && !${itemLimit.Equal[NULL]}) {
            /varcalc itemsWithIniEntry ${itemsWithIniEntry} + 1
        }
        
        | Priority 1: SELL - always sell - same as AutoSell line 2280
        /if (${itemLimitUpper.Equal[SELL]}) {
            | Display immediately (mirrors SellItem call at line 2283)
            /call DisplayDryRunSellItem 0 ${slotNum} "${itemName}" "\ag[SELL]\aw"
            /continue
        }
        
        | Check for BANK items in main inventory (show notice even though we can't bank them) - same as AutoSell
        /if (${itemLimitUpper.Equal[BANK]}) {
            /call AnnounceBankSell "${tlTag} \aoNOTICE: Item ${itemLink} \aoin main inventory slot ${slotNum} is marked \agBANK\ao."
            /call AnnounceBankSell "${tlTag} \arACTION REQUIRED: Move ${itemLink} \arto a bag (pack1-pack10); then run \ag/mac turboloot bank\ar to bank it. This is a limitation of MQ."
            /continue
        }
        
        | Priority 2: KEEP, ALL, or numeric - never sell (same as AutoSell)
        /if (${itemLimitUpper.Equal[KEEP]} || ${itemLimitUpper.Equal[ALL]} || (${Int[${itemLimit}]} > 0)) {
            /if (${showDebug}) {
                /echo \ag[AutoSell]\ag Skipping ${itemLink}\ag - marked as \agKEEP\aw/\agALL\aw/\ay#\aw
            }
            /continue
        }
        
        | Priority 3: IGNORE - never sell (same as KEEP for selling) - same as AutoSell
        /if (${itemLimitUpper.Equal[IGNORE]}) {
            /if (${showDebug}) {
                /echo \ag[AutoSell]\ao Skipping ${itemLink}\ao - marked as \aoIGNORE
            }
            /continue
        }

        | Priority 4: Wildcard auto-sell (optional) - same as AutoSell line 2313
        | - ON: auto-sell wildcards unless explicitly protected via KEEP/IGNORE/BANK/TRIBUTE
        | - OFF: never auto-sell wildcards (but explicit Item=SELL still sells)
        /if (${sellWildcards} && ${IsWildcardItem[${itemName}]}) {
            /if (${itemLimitUpper.Equal[KEEP]} || ${itemLimitUpper.Equal[ALL]} || ${itemLimitUpper.Equal[IGNORE]} || ${itemLimitUpper.Equal[BANK]} || ${itemLimitUpper.Equal[TRIBUTE]} || (${Int[${itemLimit}]} > 0)) {
                /continue
            }
            | Display immediately (mirrors SellItem call)
            /call DisplayDryRunSellItem 0 ${slotNum} "${itemName}" "\ay[Wildcard]\aw"
            /continue
        }
        
        | Priority 5: Sell unlisted stackables (optional) - same as AutoSell line 2302
        | Behavior: sell any unlisted stackable item with vendor value (if SellUnlistedStackable=ON)
        /if (${enableSellStackable} && ${Me.Inventory[${slotNum}].Stackable} && (!${IsWildcardItem[${itemName}]} || ${sellWildcards})) {
            | Check if item is truly unlisted (no INI entry or empty/NULL)
            /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
                | Item is unlisted - check if it has vendor value
                /if (${Me.Inventory[${slotNum}].Value} > 0) {
                    | Double-check it's not marked as KEEP/ALL/numeric
                    /if (${itemLimitUpper.NotEqual[KEEP]} && ${itemLimitUpper.NotEqual[ALL]} && ${Int[${itemLimit}]} <= 0) {
                        | Display immediately (mirrors SellItem call)
                        /call DisplayDryRunSellItem 0 ${slotNum} "${itemName}" "\ao(Unlisted stackable)\aw"
                        /continue
                    }
                }
            }
        }

        | Priority 6: Sell ANY unlisted item (not just stackables) - same as AutoSell line 2350
        | Behavior: sell any unlisted item that has vendor value (if sellUnlistedItems=ON)
        /if (${enableSellUnlistedValue} && (!${IsWildcardItem[${itemName}]} || ${sellWildcards})) {
            | Check if item is truly unlisted (no INI entry or empty/NULL)
            /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
                | Item is unlisted - check if it has vendor value
                /if (${Me.Inventory[${slotNum}].Value} > 0) {
                    | Double-check it's not marked as KEEP/ALL/numeric
                    /if (${itemLimitUpper.NotEqual[KEEP]} && ${itemLimitUpper.NotEqual[ALL]} && ${Int[${itemLimit}]} <= 0) {
                        | Display immediately (mirrors SellItem call)
                        /call DisplayDryRunSellItem 0 ${slotNum} "${itemName}" "\ao(Unlisted item)\aw"
                        /continue
                    }
                }
            }
        }
    /next slotNum
    
    /if (${showDebug}) /echo [turboLoot] DBG(progress) ${tlTag} \ayFinished scanning main inventory slots - now scanning bags...
    
    | Now scan all inventory bags - same as AutoSell line 2375
    /for packNum 1 to 10
        | Note: No merchant window check needed for dry-run (we're not actually selling)
        
        | Check if pack exists first - check Container property (0 means pack doesn't exist or isn't a container)
        /varset maxSlots ${Me.Inventory[pack${packNum}].Container}
        /if (${maxSlots} == 0) /continue
        
        /for slotNum 1 to ${maxSlots}
            | Process events to keep macro responsive
            /doevents
            
            | Get item name directly - same as AutoSell line 2391
            /varset itemName ${Me.Inventory[pack${packNum}].Item[${slotNum}].Name}
            /if (!${itemName.Length} || ${itemName.Equal[NULL]}) /continue
            
            | Check [ItemLimits] for this item (direct INI lookup with case-insensitive fallback) - same as AutoSell line 2395
            /varcalc totalItemsChecked ${totalItemsChecked} + 1
            /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName}]}
            /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
                /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Upper}]}
            }
            /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
                /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Lower}]}
            }
            | Safety check: ensure itemLimit is initialized before string operations
            /if (!${itemLimit.Length}) /varset itemLimit ""
            /varset itemLimitUpper ${itemLimit.Upper}
            /varset itemLimitUpper ${itemLimitUpper.Replace[ ,]}
            /if (${itemLimitUpper.Equal[SKIP]}) /varset itemLimitUpper IGNORE
            | Set itemLink and iniColor for this bag slot iteration (variables already declared at start of subroutine)
            /varset itemLink ${Me.Inventory[pack${packNum}].Item[${slotNum}].ItemLink[CLICKABLE]}
            /varset iniColor \aw
            
            | Track items with INI entries for debugging
            /if (${itemLimit.Length} && !${itemLimit.Equal[NULL]}) {
                /varcalc itemsWithIniEntry ${itemsWithIniEntry} + 1
            }
            
            | Priority 1: SELL - always sell - same as AutoSell line 2418
            /if (${itemLimitUpper.Equal[SELL]}) {
                | Display immediately (mirrors SellItem call at line 2419)
                /call DisplayDryRunSellItem ${packNum} ${slotNum} "${itemName}" "\ag[SELL]\aw"
                /continue
            }
            
            | Priority 2: KEEP, ALL, or numeric - never sell (same as AutoSell)
            /if (${itemLimitUpper.Equal[KEEP]} || ${itemLimitUpper.Equal[ALL]} || (${Int[${itemLimit}]} > 0)) {
                /if (${showDebug}) {
                    /echo \ag[AutoSell]\ag Skipping ${itemLink}\ag - marked as \agKEEP\aw/\agALL\aw/\ay#\aw
                }
                /continue
            }
            
            | Priority 3: IGNORE - never sell (same as KEEP for selling) - same as AutoSell
            /if (${itemLimitUpper.Equal[IGNORE]}) {
                /if (${showDebug}) {
                    /echo \ag[AutoSell]\ao Skipping ${itemLink}\ao - marked as \aoIGNORE
                }
                /continue
            }

            | Priority 4: Wildcard auto-sell (optional) - same as AutoSell
            | - ON: auto-sell wildcards unless explicitly protected via KEEP/ALL/#/IGNORE/BANK/TRIBUTE
            | - OFF: never auto-sell wildcards (but explicit Item=SELL still sells)
            /if (${sellWildcards} && ${IsWildcardItem[${itemName}]}) {
                /if (${itemLimitUpper.Equal[KEEP]} || ${itemLimitUpper.Equal[ALL]} || ${itemLimitUpper.Equal[IGNORE]} || ${itemLimitUpper.Equal[BANK]} || ${itemLimitUpper.Equal[TRIBUTE]} || (${Int[${itemLimit}]} > 0)) {
                    /continue
                }
                | Display immediately (mirrors SellItem call at line 2446)
                /call DisplayDryRunSellItem ${packNum} ${slotNum} "${itemName}" "\ay[Wildcard]\aw"
                /continue
            }
            
            | Priority 5: Sell unlisted stackables (optional) - same as AutoSell line 2454
            | Behavior: sell any unlisted stackable item with vendor value (if SellUnlistedStackable=ON)
            /if (${enableSellStackable} && ${Me.Inventory[pack${packNum}].Item[${slotNum}].Stackable} && (!${IsWildcardItem[${itemName}]} || ${sellWildcards})) {
                | Check if item is truly unlisted (no INI entry or empty/NULL)
                /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
                    | Item is unlisted - check if it has vendor value
                    /if (${Me.Inventory[pack${packNum}].Item[${slotNum}].Value} > 0) {
                        | Double-check it's not marked as KEEP/ALL/numeric (shouldn't happen if unlisted, but safety check)
                        /if (${itemLimitUpper.NotEqual[KEEP]} && ${itemLimitUpper.NotEqual[ALL]} && ${Int[${itemLimit}]} <= 0) {
                            | Display immediately (mirrors SellItem call at line 2467)
                            /call DisplayDryRunSellItem ${packNum} ${slotNum} "${itemName}" "\ao(Unlisted stackable)\aw"
                            /continue
                        }
                    }
                }
            }
            
            | Priority 6: Sell ANY unlisted item (not just stackables) - same as AutoSell line 2470
            | Behavior: sell any unlisted item that has vendor value (if sellUnlistedItems=ON)
            /if (${enableSellUnlistedValue} && (!${IsWildcardItem[${itemName}]} || ${sellWildcards})) {
                | Check if item is truly unlisted (no INI entry or empty/NULL)
                /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
                    | Item is unlisted - check if it has vendor value
                    /if (${Me.Inventory[pack${packNum}].Item[${slotNum}].Value} > 0) {
                        | Double-check it's not marked as KEEP/ALL/numeric
                        /if (${itemLimitUpper.NotEqual[KEEP]} && ${itemLimitUpper.NotEqual[ALL]} && ${Int[${itemLimit}]} <= 0) {
                            | Display immediately (mirrors SellItem call)
                            /call DisplayDryRunSellItem ${packNum} ${slotNum} "${itemName}" "\ao(Unlisted item)\aw"
                            /continue
                        }
                    }
                }
            }
        /next slotNum
    /next packNum
    
    | Print summary unless skipSummary was set
    /if (!${skipSummary}) {
        /call PrintDryRunSellSummary
    }
/return


|| ---------------------------------------------------------------------
|| AUTO BANK
|| ---------------------------------------------------------------------
Sub AutoBank
    | Use outer variables (declared in InitState) - no local declares needed
    
    /varset itemsBanked 0
    
    | Local variables for tracking
    /declare totalItemsChecked int local 0
    /declare itemsWithIniEntry int local 0
    | Declare itemLink and iniColor once for the entire subroutine (used in both main inventory and bag loops)
    /declare itemLink string local
    /declare iniColor string local
    
    /call AnnounceBankSell "${tlTag} \au======================================================="
    /call AnnounceBankSell "${tlTag} \aoStarting turboBank process..."

    | Drop levitation before navigating - lev interferes with MQ2Nav pathing
    /if (${Me.Levitating}) {
        /call AnnounceBankSellProgress "${tlTag} \ayDetected levitation - removing before navigating..."
        /removelev
        /delay 10 !${Me.Levitating}
        /if (${Me.Levitating}) /call AnnounceBankSell "${tlTag} \aoWARNING: Could not remove levitation. This may cause navigation issues."
    }

    | Clear any existing target to ensure we find the nearest banker
    | This prevents issues when user has a non-banker NPC or other entity targeted
    /target clear
    /delay 1
    
    | Check if bank window is open, if not try to find and open one
    /if (!${Window[BigBankWnd].Open}) {
        /call AnnounceBankSellProgress "${tlTag} \ayBank window not open - attempting to find and open banker..."
        
        | Check if banker is already targeted first (fast path - only try opening if close enough)
        | Exclude players (PC) and self to prevent issues
        /if (${Target.ID} && ${Target.ID} != ${Me.ID} && ${Target.Type.NotEqual[PC]} && (${Target.Type.Equal[Banker]} || ${Target.Type.Equal[NPC]})) {
            | Banker is targeted - only try opening window if close enough (avoid delay when far away)
            /if (${Target.Distance} <= 10) {
                /click right target
                /delay 100 ${Window[BigBankWnd].Open}
                /doevents
            }
        }
        
        | If still not open, try targeting nearest banker first
        /if (!${Window[BigBankWnd].Open}) {
            | Try multiple methods to find banker
            | Method 1: Check if banker is already targeted (exclude PC and self explicitly)
            | Retarget if: no target, target is self, target is PC, or target is not Banker/NPC
            /if (!${Target.ID} || ${Target.ID} == ${Me.ID} || ${Target.Type.Equal[PC]} || (${Target.Type.NotEqual[Banker]} && ${Target.Type.NotEqual[NPC]})) {
                | Method 2: Target nearest NPC banker using spawn search
                /target npc banker
                /delay 1
            }
            
            | If still no banker, try broader search
            /if (!${Target.ID} || ${Target.ID} == ${Me.ID} || ${Target.Type.Equal[PC]} || (${Target.Type.NotEqual[Banker]} && ${Target.Type.NotEqual[NPC]})) {
                | Method 3: Use SpawnCount to find bankers
                /if (${SpawnCount[npc banker radius 200]} > 0) {
                    /target npc banker radius 200
                    /delay 1
                }
            }
        }
        
        | Accept target if it's a banker OR an NPC (manual targeting might show NPC type)
        | Exclude players (PC) and self to prevent issues
        /if (${Target.ID} && ${Target.ID} != ${Me.ID} && ${Target.Type.NotEqual[PC]} && (${Target.Type.Equal[Banker]} || ${Target.Type.Equal[NPC]})) {
            /call AnnounceBankSellProgress "${tlTag} \ayFound banker: \aw${Target.CleanName} \ay(distance: \aw${Target.Distance}\ay; type: \aw${Target.Type}\ay)"
            
            | Navigate to banker if too far away
            /if (${Target.Distance} > 10) {
                /call AnnounceBankSellProgress "${tlTag} \ayNavigating to banker (distance: \aw${Target.Distance} \ayunits)..."
                /face fast
                
                | Try nav first (proper pathfinding), fall back to moveto if unavailable
                /declare navTries int local 0
                /declare bankerID int local ${Target.ID}
                /declare usedNav bool local FALSE
                
                /if (${Navigation.PathExists[id ${Target.ID}]}) {
                    /if (${showDebug}) /echo [turboLoot] Using /nav to reach banker
                    /nav id ${Target.ID} distance=10
                    | Wait for nav to complete (up to 15 seconds)
                    /delay 150 !${Navigation.Active} || ${Target.Distance} <= 10
                    /if (${Navigation.Active}) {
                        /squelch /nav stop
                    }
                    /varset usedNav TRUE
                }
                
                | If nav got us close enough, skip the moveto loop
                /if (${Target.Distance} <= 10) /goto :reachedBanker
                
                | Fallback moveto loop
                :moveToBanker
                /if (${Target.Distance} <= 10) /goto :reachedBanker
                
                | Check if target is still valid
                /if (!${Target.ID} || ${Target.ID} != ${bankerID}) {
                    /call AnnounceBankSell "${tlTag} \arERROR: Lost banker target during navigation"
                    /return
                }
                
                /varcalc navTries ${navTries} + 1
                /if (${navTries} > 50) {
                    /call AnnounceBankSell "${tlTag} \aoWARNING: Could not reach banker after \aw${navTries} \aoattempts (distance: \aw${Target.Distance}\ao)"
                    /call AnnounceBankSellProgress "${tlTag} \ayAttempting to open window anyway..."
                    /goto :reachedBanker
                }
                
                /face fast
                /moveto id ${Target.ID} dist 10
                /delay 5
                /doevents
                /goto :moveToBanker
                
                :reachedBanker
                /if (${Target.Distance} <= 10) {
                    /call AnnounceBankSellProgress "${tlTag} \agReached banker (distance: \aw${Target.Distance}\ag)"
                } else {
                    /call AnnounceBankSell "${tlTag} \aoWARNING: Could not fully reach banker (distance: \aw${Target.Distance}\ao) - attempting to open window anyway"
                }
            }
            
            | Face banker and open window
            /face fast
            /delay 1
            
            | Right-click banker to open bank window
            /click right target
            
            | Wait for window to open (conditional delay - exits early when window opens)
            /delay 100 ${Window[BigBankWnd].Open}
            /doevents
            
            /if (${Window[BigBankWnd].Open}) {
                /call AnnounceBankSellProgress "${tlTag} \agBank window opened: \aw${Target.CleanName}"
            } else {
                /call AnnounceBankSell "${tlTag} \arERROR: Failed to open bank window"
                /call AnnounceBankSell "${tlTag} \awPlease manually target a banker and open their window - then try again"
                /return
            }
        } else {
            /call AnnounceBankSell "${tlTag} \arERROR: No banker found nearby"
            /call AnnounceBankSell "${tlTag} \awPlease manually target a banker and open their window - then try again"
            /return
        }
    } else {
        /call AnnounceBankSellProgress "${tlTag} \agBank window already open"
    }
    
    | Scan all inventory (main slots + bags)
    /call AnnounceBankSellProgress "${tlTag} \agScanning inventory for items marked BANK..."
    
    | First scan main inventory slots (23-32 = slots 1-10 outside bags)
    | Note: Some servers have 10 inventory slots, not 8
    /call AnnounceBankSellProgress "${tlTag} \ayScanning main inventory slots (23-32)..."
    /for slotNum 23 to 32
        | Process events to keep macro responsive
        /doevents
        
        | Check if bank window is still open (periodic check)
        /if (!${Window[BigBankWnd].Open}) {
            /call AnnounceBankSell "${tlTag} \arERROR: Bank window closed during scan!"
            /return
        }
        
        | Get item name directly (main inventory slots use direct slot access)
        | Use .Name explicitly to ensure we get the full item name
        /varset itemName ${Me.Inventory[${slotNum}].Name}
        | Set itemLink for this main inventory slot iteration (variable already declared at start of subroutine)
        /varset itemLink ${Me.Inventory[${slotNum}].ItemLink[CLICKABLE]}
        /if (${showDebug} && ${itemName.Length} && !${itemName.Equal[NULL]}) {
            /call AnnounceBankSell "${tlTag} \ayMain inventory slot ${slotNum}: ${itemLink}"
        }
        /if (!${itemName.Length} || ${itemName.Equal[NULL]}) /continue
        
        | Check [ItemLimits] for this item (direct INI lookup with case-insensitive fallback)
        /varcalc totalItemsChecked ${totalItemsChecked} + 1
        /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName}]}
        /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
            /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Upper}]}
        }
        /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
            /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Lower}]}
        }
        /varset itemLimitUpper ${itemLimit.Upper}
        /varset itemLimitUpper ${itemLimitUpper.Replace[ ,]}
        /if (${itemLimitUpper.Equal[SKIP]}) /varset itemLimitUpper IGNORE
        | Determine color for INI value based on type (reuse iniColor already declared)
        /varset iniColor \aw
        /if (${itemLimitUpper.Equal[KEEP]}) /varset iniColor \ag
        /if (${itemLimitUpper.Equal[ALL]}) /varset iniColor \at
        /if (${itemLimitUpper.Equal[DESTROY]}) /varset iniColor \ar
        /if (${itemLimitUpper.Equal[IGNORE]}) /varset iniColor \ao
        /if (${itemLimitUpper.Equal[SELL]}) /varset iniColor \ag
        /if (${itemLimitUpper.Equal[BANK]}) /varset iniColor \ap
        | Check if it's a number (value limit) - only check numeric if not already set to a keyword
        /if (${iniColor.Equal[\aw]} && ${itemLimit.Length} && ${itemLimit.NotEqual[NULL]} && ${itemLimit.NotEqual[0]}) {
            | Try to convert to int - if it succeeds and is in valid range, it's a number
            /if (${Int[${itemLimit}]} > 0 && ${Int[${itemLimit}]} < 10000) /varset iniColor \ay
        }
        
        | Track items with INI entries for debugging
        /if (${itemLimit.Length} && !${itemLimit.Equal[NULL]}) {
            /varcalc itemsWithIniEntry ${itemsWithIniEntry} + 1
        }
        
        | Priority 1: BANK - always bank (includes wildcard matches if enabled)
        | Check for wildcard match if bankWildcards is enabled and item isn't already marked BANK
        /if (${bankWildcards} && !${itemLimitUpper.Equal[BANK]} && !${itemLimitUpper.Equal[KEEP]} && !${itemLimitUpper.Equal[ALL]} && !${itemLimitUpper.Equal[IGNORE]} && !${itemLimitUpper.Equal[SELL]} && ${Int[${itemLimit}]} <= 0) {
            /if (${itemName.Find[Spell:]} || ${itemName.Find[Tome:]} || ${itemName.Find[Tome of]} || ${itemName.Find[Song:]} || ${itemName.Find[Combat:]} || ${itemName.Find[Skill:]}) {
                /varset itemLimitUpper BANK
                /if (${showDebug}) /echo [AutoBank] Wildcard match: ${itemName} -> BANK
            }
        }
        /if (${itemLimitUpper.Equal[BANK]}) {
            | Use bagNum=0 to indicate main inventory, pass actual slot number (23-32)
            /call BankItem 0 ${slotNum} "${itemName}"
            /continue
        }
        
        | Check for SELL items in main inventory (show notice even though we're in bank mode)
        /if (${itemLimitUpper.Equal[SELL]}) {
            /call AnnounceBankSell "${tlTag} \aoNOTICE/ACTION REQUIRED:\aw ${itemLink} \aoin main inventory slot ${slotNum} is marked \agSELL\ao. \arMove it to a bag, then run \ag/mac turboloot sell\ar. \ay(MQ limitation)\ax"
            /continue
        }
        
        | Priority 2: KEEP, ALL, or numeric - never bank (keep in inventory unless explicitly BANK/SELL/TRIBUTE)
        /if (${itemLimitUpper.Equal[KEEP]} || ${itemLimitUpper.Equal[ALL]} || (${Int[${itemLimit}]} > 0)) {
            /if (${showDebug}) {
                /echo \ag[AutoBank]\ag Skipping ${itemLink}\ag - marked as \agKEEP\aw/\agALL\aw/\ay#\aw
            }
            /continue
        }
        
        | Priority 3: IGNORE - never bank (same as KEEP for banking)
        /if (${itemLimitUpper.Equal[IGNORE]}) {
            /if (${showDebug}) {
                /echo \ag[AutoBank]\ao Skipping ${itemLink}\ao - marked as \aoIGNORE
            }
            /continue
        }
    /next slotNum
    
    /if (${showDebug}) /echo [turboLoot] DBG(progress) ${tlTag} \ayFinished scanning main inventory slots - now scanning bags...
    
    | Now scan all inventory bags
    /for packNum 1 to 10
        | Check if bank window is still open (periodic check)
        /if (!${Window[BigBankWnd].Open}) {
            /call AnnounceBankSell "${tlTag} \arERROR: Bank window closed during scan!"
            /return
        }
        
        | Check if pack exists first - check Container property (0 means pack doesn't exist or isn't a container)
        /varset maxSlots ${Me.Inventory[pack${packNum}].Container}
        /if (${maxSlots} == 0) /continue
        
        /for slotNum 1 to ${maxSlots}
            | Process events to keep macro responsive
            /doevents
            
            | Get item name directly
            /varset itemName ${Me.Inventory[pack${packNum}].Item[${slotNum}].Name}
            /if (!${itemName.Length} || ${itemName.Equal[NULL]}) /continue
            
            | Check [ItemLimits] for this item (direct INI lookup with case-insensitive fallback)
            /varcalc totalItemsChecked ${totalItemsChecked} + 1
            /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName}]}
            /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
                /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Upper}]}
            }
            /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) {
                /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Lower}]}
            }
            | Safety check: ensure itemLimit is initialized before string operations
            /if (!${itemLimit.Length}) /varset itemLimit ""
            /varset itemLimitUpper ${itemLimit.Upper}
            /varset itemLimitUpper ${itemLimitUpper.Replace[ ,]}
            /if (${itemLimitUpper.Equal[SKIP]}) /varset itemLimitUpper IGNORE
            | Set itemLink and iniColor for this bag slot iteration (variables already declared at start of subroutine)
            /varset itemLink ${Me.Inventory[pack${packNum}].Item[${slotNum}].ItemLink[CLICKABLE]}
            /varset iniColor \aw
            
            | Track items with INI entries for debugging
            /if (${itemLimit.Length} && !${itemLimit.Equal[NULL]}) {
                /varcalc itemsWithIniEntry ${itemsWithIniEntry} + 1
            }
            
            | Priority 1: BANK - always bank (includes wildcard matches if enabled)
            | Check for wildcard match if bankWildcards is enabled and item isn't already marked BANK
            /if (${bankWildcards} && !${itemLimitUpper.Equal[BANK]} && !${itemLimitUpper.Equal[KEEP]} && !${itemLimitUpper.Equal[ALL]} && !${itemLimitUpper.Equal[IGNORE]} && !${itemLimitUpper.Equal[SELL]} && ${Int[${itemLimit}]} <= 0) {
                /if (${itemName.Find[Spell:]} || ${itemName.Find[Tome:]} || ${itemName.Find[Song:]} || ${itemName.Find[Combat:]} || ${itemName.Find[Skill:]}) {
                    /varset itemLimitUpper BANK
                    /if (${showDebug}) /echo [AutoBank] Wildcard match: ${itemName} -> BANK
                }
            }
            /if (${itemLimitUpper.Equal[BANK]}) {
                /call BankItem ${packNum} ${slotNum} "${itemName}"
                /continue
            }
            
            | Priority 2: KEEP, ALL, or numeric - never bank (keep in inventory unless explicitly BANK/SELL/TRIBUTE)
            /if (${itemLimitUpper.Equal[KEEP]} || ${itemLimitUpper.Equal[ALL]} || (${Int[${itemLimit}]} > 0)) {
                /if (${showDebug}) {
                    /echo \ag[AutoBank]\ag Skipping ${itemLink}\ag - marked as \agKEEP\aw/\agALL\aw/\ay#\aw
                }
                /continue
            }
            
            | Priority 3: IGNORE - never bank (same as KEEP for banking)
            /if (${itemLimitUpper.Equal[IGNORE]}) {
                /if (${showDebug}) {
                    /echo \ag[AutoBank]\ao Skipping ${itemLink}\ao - marked as \aoIGNORE
                }
                /continue
            }
            
        /next slotNum
    /next packNum
    
    /call AnnounceBankSell "${tlTag} \agturboBank complete. \awItems checked: \ay${totalItemsChecked}\aw; Items with INI entries: \ay${itemsWithIniEntry}\aw; Items banked: \ag${itemsBanked}"
    /if (${itemsBanked} == 0 && ${totalItemsChecked} > 0) {
        /call AnnounceBankSell "${tlTag} \aoWARNING: No items were banked. Check your turboloot.ini [ItemLimits] section."
        /call AnnounceBankSell "${tlTag} \awItems must be marked as \apBANK (e.g. ItemName=BANK) to be banked."
    }
    
    | Close bank window when done
    /if (${Window[BigBankWnd].Open}) {
        /notify BigBankWnd DoneButton leftmouseup
        /delay 5 !${Window[BigBankWnd].Open}
        /if (${Window[BigBankWnd].Open}) {
            /call AnnounceBankSellProgress "${tlTag} \ayClosing bank window..."
            /windowstate BigBankWnd close
        }
    }
/return

    }
/return

||| ---------------------------------------------------------------------
||| AUTO TRIBUTE (main tribute subroutine)
||| ---------------------------------------------------------------------
Sub AutoTribute

    | Reset delta-tracked totals for this run
    /varset itemsTributed 0
    /varset tributeItemsMoved 0
    /varset tributePointsGained 0

    /declare totalItemsChecked int local 0
    /declare itemsWithIniEntry int local 0
    /declare itemLink string local
    /declare iniColor string local
    /declare itemTributeValue int local 0
    
    /call AnnounceBankSell "${tlTag} \au======================================================="
    /call AnnounceBankSell "${tlTag} \aoStarting turboTribute process..."

    | Drop levitation before navigating - lev interferes with MQ2Nav pathing
    /if (${Me.Levitating}) {
        /call AnnounceBankSellProgress "${tlTag} \ayDetected levitation - removing before navigating..."
        /removelev
        /delay 10 !${Me.Levitating}
        /if (${Me.Levitating}) /call AnnounceBankSell "${tlTag} \aoWARNING: Could not remove levitation. This may cause navigation issues."
    }

    | Clear any existing target to ensure we find the nearest tribute master
    | This prevents issues when user has a non-tribute master NPC or other entity targeted
    /target clear
    /delay 1
    
    | Check if tribute window is open, if not try to find and open one
    /if (!${Window[TributeMasterWnd].Open}) {
        /call AnnounceBankSellProgress "${tlTag} \ayTribute window not open - attempting to find and open tribute master..."
        
        | Check if tribute master is already targeted first (fast path - only try opening if close enough)
        | Exclude players (PC) and self to prevent issues
        /if (${Target.ID} && ${Target.ID} != ${Me.ID} && ${Target.Type.NotEqual[PC]} && ${Target.Type.Equal[NPC]}) {
            | Tribute master is targeted - only try opening window if close enough (avoid delay when far away)
            /if (${Target.Distance} <= 10) {
                /click right target
                /delay 100 ${Window[TributeMasterWnd].Open}
                /doevents
            }
        }
        
        | If still not open, try targeting nearest tribute master first
        /if (!${Window[TributeMasterWnd].Open}) {
            | Try multiple methods to find tribute master
            | Method 1: Check if tribute master is already targeted (exclude PC and self explicitly)
            | Retarget if: no target, target is self, target is PC, or target is not NPC
            /if (!${Target.ID} || ${Target.ID} == ${Me.ID} || ${Target.Type.Equal[PC]} || ${Target.Type.NotEqual[NPC]}) {
                | Method 2: Target nearest NPC tribute master using spawn search
                /target npc tribute
                /delay 1
            }
            
            | If still no tribute master, try broader search
            /if (!${Target.ID} || ${Target.ID} == ${Me.ID} || ${Target.Type.Equal[PC]} || ${Target.Type.NotEqual[NPC]}) {
                | Method 3: Use SpawnCount to find tribute masters
                /if (${SpawnCount[npc tribute radius 200]} > 0) {
                    /target npc tribute radius 200
                    /delay 1
                }
            }
            
            | Accept target if it's an NPC (exclude players and self)
            /if (${Target.ID} && ${Target.ID} != ${Me.ID} && ${Target.Type.NotEqual[PC]} && ${Target.Type.Equal[NPC]}) {
                /call AnnounceBankSellProgress "${tlTag} \ayFound Tribute Master: \aw${Target.CleanName} \ay(distance: \aw${Target.Distance}\ay)"
                
                | Navigate to tribute master if needed
                /if (${Target.Distance} > 15) {
                    /call AnnounceBankSellProgress "${tlTag} \ayNavigating to tribute master..."
/declare tributeID int local ${Target.ID}

| Nav-only approach (no MQ2MoveUtils). Includes door-open + nudge if stuck.
/call NavToIDWithDoorsAndNudges ${tributeID} 10 900

| Verify target still valid
/if (!${Target.ID} || ${Target.ID} != ${tributeID}) {
    /call AnnounceBankSell "${tlTag} \arERROR: Lost tribute master target during navigation"
    /return
}

:reachedTribute
/face fast
/delay 1
                }
                
                | Open tribute window
                /click right target
                /delay 100 ${Window[TributeMasterWnd].Open}
                /doevents
            }
        }
    }
    
    | Verify tribute window is open
    /if (!${Window[TributeMasterWnd].Open}) {
        /call AnnounceBankSell "${tlTag} \arERROR: Could not open Tribute Master window. Please target a Tribute Master NPC and try again."
        /return
    }
    
    /call AnnounceBankSellProgress "${tlTag} \agTribute Master window open. Scanning inventory for items marked TRIBUTE..."

    | Scan bags first (more likely to have tribute items, and main inventory items can't be tributed anyway)
    | Process bags immediately to start tributing faster
    /for packNum 1 to 10
        /if (!${Me.Inventory[pack${packNum}].ID}) /continue
        /varset maxSlots ${Me.Inventory[pack${packNum}].Container}
        
        | Process slots in reverse order to avoid skipping items when inventory shifts after tributing
        /for slotNum ${maxSlots} downto 1
            /varcalc totalItemsChecked ${totalItemsChecked} + 1
            /if (!${Me.Inventory[pack${packNum}].Item[${slotNum}].ID}) /continue
            
            /varset itemName ${Me.Inventory[pack${packNum}].Item[${slotNum}].Name}
            /if (!${itemName.Length} || ${itemName.Equal[NULL]}) /continue
            
            | Look up INI entry (case-insensitive like main looting loop)
            /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName}]}
            /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]}) {
                | Try uppercase
                /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Upper}]}
            }
            /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]}) {
                | Try lowercase
                /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Lower}]}
            }
            /if (${itemLimit.Length} && !${itemLimit.Equal[NULL]}) {
                /varset itemLimitUpper ${itemLimit.Upper}
                /varset itemLimitUpper ${itemLimitUpper.Replace[ ,]}
                /if (${itemLimitUpper.Equal[SKIP]}) /varset itemLimitUpper IGNORE
                /varcalc itemsWithIniEntry ${itemsWithIniEntry} + 1
            } else {
                /varset itemLimitUpper ""
            }
            
            | Check if item is marked TRIBUTE in INI, OR unlisted with tribute value (looted via lootTribMinValue)
            /varset itemTributeValue ${Me.Inventory[pack${packNum}].Item[${slotNum}].Tribute}
            /if (${itemLimitUpper.Equal[TRIBUTE]} || (!${itemLimitUpper.Length} && ${itemTributeValue} > 0)) {
                | Verify item still exists and has tribute value > 0 (inventory may have shifted)
                /if (!${Me.Inventory[pack${packNum}].Item[${slotNum}].ID} || !${Me.Inventory[pack${packNum}].Item[${slotNum}].Name.Equal[${itemName}]}) /continue
                /if (${itemTributeValue} > 0) {
                    /if (${showDebug}) /call AnnounceBankSell "${tlTag} \ay[DEBUG] Processing TRIBUTE item: ${itemName} in pack${packNum} slot${slotNum} (tribute value: ${itemTributeValue})"
                    /call TributeItem ${packNum} ${slotNum} "${itemName}"
                    | Small delay after tribute to allow inventory to update before checking next item
                    /delay 1
                } else {
                    | Item marked TRIBUTE but has 0 tribute value - notify user
                    /call AnnounceBankSell "${tlTag} \aoWARNING: Item ${Me.Inventory[pack${packNum}].Item[${slotNum}].ItemLink[CLICKABLE]} \aois marked \ayTRIBUTE\ao but has tribute value \ar0\ao (cannot be tributed)"
                }
            }
        /next slotNum
    /next packNum
    
    | Scan main inventory slots (23-32) - these can't be tributed but we check for user info
    /for slotNum 23 to 32
        /varcalc totalItemsChecked ${totalItemsChecked} + 1
        /if (!${Me.Inventory[${slotNum}].ID}) /continue
        
        /varset itemName ${Me.Inventory[${slotNum}].Name}
        /if (!${itemName.Length} || ${itemName.Equal[NULL]}) /continue
        
        | Look up INI entry (case-insensitive like main looting loop)
        /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName}]}
        /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]}) {
            | Try uppercase
            /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Upper}]}
        }
        /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]}) {
            | Try lowercase
            /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Lower}]}
        }
        /if (${itemLimit.Length} && !${itemLimit.Equal[NULL]}) {
            /varset itemLimitUpper ${itemLimit.Upper}
            /varset itemLimitUpper ${itemLimitUpper.Replace[ ,]}
            /if (${itemLimitUpper.Equal[SKIP]}) /varset itemLimitUpper IGNORE
            /varcalc itemsWithIniEntry ${itemsWithIniEntry} + 1
        } else {
            /varset itemLimitUpper ""
        }
        
        | Check if item is marked TRIBUTE - notify user they need to move to bag
        /if (${itemLimitUpper.Equal[TRIBUTE]}) {
            /varset itemTributeValue ${Me.Inventory[${slotNum}].Tribute}
            /if (${itemTributeValue} > 0) {
                /declare mainInvItemLink string local ${Me.Inventory[${slotNum}].ItemLink[CLICKABLE]}
                /call AnnounceBankSell "${tlTag} \aoNOTICE: Item ${mainInvItemLink} \aoin main inventory slot ${slotNum} is marked \ayTRIBUTE\ao."
                /call AnnounceBankSell "${tlTag} \arACTION REQUIRED: Move ${mainInvItemLink} \arto a bag (pack1-pack10); then run \ag/mac turboloot tribute\ar again to tribute it. This is a limitation of MQ."
            }
        }
    /next slotNum

    /call AnnounceBankSell "${tlTag} \agturboTribute complete. \awItems checked: \ay${totalItemsChecked}\aw; Items with INI entries: \ay${itemsWithIniEntry}\aw; Units tributed: \ay${tributeItemsMoved}\aw; Tribute gained: \ay${tributePointsGained}"
    /if (${tributeItemsMoved} == 0 && ${totalItemsChecked} > 0) {
        /call AnnounceBankSell "${tlTag} \aoWARNING: No items were tributed. Check your turboloot.ini [ItemLimits] section."
        /call AnnounceBankSell "${tlTag} \awItems must be marked as \ayTRIBUTE (e.g. ItemName=TRIBUTE) to be tributed."
    }

    | Close tribute window when done (avoid ESC; it's context-sensitive)
    /if (${Window[TributeMasterWnd].Open}) {
        /squelch /notify TributeMasterWnd DoneButton leftmouseup
        /squelch /notify TributeMasterWnd TMW_DoneButton leftmouseup
        /delay 2 !${Window[TributeMasterWnd].Open}
        /if (${Window[TributeMasterWnd].Open}) /windowstate TributeMasterWnd close
        /delay 5 !${Window[TributeMasterWnd].Open}
    }
/return

||| ---------------------------------------------------------------------
||| AUTO DESTROY (destroys items in inventory marked DESTROY)
||| ---------------------------------------------------------------------
Sub AutoDestroy
    /varset itemsDestroyed 0
    /declare totalItemsChecked int local 0
    /declare itemsWithIniEntry int local 0
    /declare itemLink string local

    /call AnnounceBankSell "${tlTag} \au======================================================="
    /call AnnounceBankSell "${tlTag} \aoStarting turboDestroy process...\aw (will destroy inventory items marked \arDESTROY\aw in your INI)"

    | Scan bag slots first (pack1-pack10)
    /for packNum 1 to 10
        /if (!${Me.Inventory[pack${packNum}].ID}) /continue

        /varset maxSlots ${Me.Inventory[pack${packNum}].Container}
        /if (${maxSlots} <= 0) /continue

        | Ensure bag window is open so /itemnotify works reliably
        /if (!${Window[pack${packNum}].Open}) {
            /nomodkey /itemnotify pack${packNum} rightmouseup
            /delay 2 ${Window[pack${packNum}].Open}
        }

        | Process slots in reverse order (inventory can shift when destroying)
        /for slotNum ${maxSlots} downto 1
            /doevents
            /if (!${Me.Inventory[pack${packNum}].Item[${slotNum}].ID}) /continue

            /varcalc totalItemsChecked ${totalItemsChecked} + 1
            /varset itemName ${Me.Inventory[pack${packNum}].Item[${slotNum}].Name}
            /if (!${itemName.Length} || ${itemName.Equal[NULL]}) /continue
            /varset itemLink ${Me.Inventory[pack${packNum}].Item[${slotNum}].ItemLink[CLICKABLE]}

            | INI lookup (case-insensitive fallback)
            /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName}]}
            /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Upper}]}
            /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Lower}]}

            /if (${itemLimit.Length} && !${itemLimit.Equal[NULL]} && !${itemLimit.Equal[0]}) {
                /varcalc itemsWithIniEntry ${itemsWithIniEntry} + 1
                /varset itemLimitUpper ${itemLimit.Upper}
                /varset itemLimitUpper ${itemLimitUpper.Replace[ ,]}
                /if (${itemLimitUpper.Equal[SKIP]}) /varset itemLimitUpper IGNORE

                /if (${itemLimitUpper.Equal[DESTROY]}) {
                    /call DestroyItem ${packNum} ${slotNum} "${itemName}"
                }
            }
        /next slotNum
    /next packNum

    | Main inventory items are not reliably handled by MQ for some actions; require moving to a bag first.
    /for slotNum 23 to 32
        /if (!${Me.Inventory[${slotNum}].ID}) /continue
        /varcalc totalItemsChecked ${totalItemsChecked} + 1
        
        | Safety check: get item name and validate
        /varset itemName ${Me.Inventory[${slotNum}].Name}
        /if (!${itemName.Length} || ${itemName.Equal[NULL]}) /continue
        
        | Safety check: get item link - ItemLink[CLICKABLE] can crash on some items
        | Use item name as fallback if ItemLink fails (safer than crashing)
        /varset itemLink ${itemName}
        | Try to get ItemLink, but don't crash if it fails - just use item name instead
        /if (${Me.Inventory[${slotNum}].ID}) {
            /varset itemLink ${Me.Inventory[${slotNum}].ItemLink[CLICKABLE]}
            | If ItemLink failed or is invalid, fall back to item name
            /if (!${itemLink.Length} || ${itemLink.Equal[NULL]}) {
                /varset itemLink ${itemName}
            }
        }

        /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName}]}
        /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Upper}]}
        /if (!${itemLimit.Length} || ${itemLimit.Equal[NULL]} || ${itemLimit.Equal[0]}) /varset itemLimit ${Ini[${iniFile},ItemLimits,${itemName.Lower}]}

        /if (${itemLimit.Length} && !${itemLimit.Equal[NULL]} && !${itemLimit.Equal[0]}) {
            /varcalc itemsWithIniEntry ${itemsWithIniEntry} + 1
            /varset itemLimitUpper ${itemLimit.Upper}
            /varset itemLimitUpper ${itemLimitUpper.Replace[ ,]}
            /if (${itemLimitUpper.Equal[SKIP]}) /varset itemLimitUpper IGNORE

            /if (${itemLimitUpper.Equal[DESTROY]}) {
                /call AnnounceBankSell "${tlTag} \aoNOTICE/ACTION REQUIRED:\aw ${itemLink} \aoin main inventory slot ${slotNum} is marked \arDESTROY\ao. \arMove it to a bag (pack1-pack10), then run \ag/mac turboloot destroy\ar. \ay(MQ limitation)\ax"
            }
        }
    /next slotNum

    /if (${itemsDestroyed} > 0) {
        /call AnnounceBankSell "${tlTag} \agturboDestroy complete.\aw Items destroyed: \ag${itemsDestroyed}\aw."
    } else {
        /call AnnounceBankSell "${tlTag} \aoturboDestroy complete.\aw No items were destroyed."
        /call AnnounceBankSell "${tlTag} \awItems must be marked as \arDESTROY\aw (e.g. \ayItemName=DESTROY\aw) to be destroyed."
    }

    /if (${showDebug}) /echo [turboLoot] DBG(destroy) checked=${totalItemsChecked} iniEntries=${itemsWithIniEntry} destroyed=${itemsDestroyed}
    /call CloseBags
/return

|| ---------------------------------------------------------------------
|| BANK ITEM (helper subroutine)
|| ---------------------------------------------------------------------
Sub BankItem(int bagNum, int slotNum, string itemName)
    | Use outer variables (declared in InitState) - no local declares for loop variables
    
    /declare currentItemName string local
    /declare itemnotifySlot int local
    | Get itemLink and itemValue before banking (so we can use them in the success message)
    | Use bankItemLink to avoid conflict with itemLink declared in AutoBank
    /declare bankItemLink string local
    | itemValue is already declared as outer - don't redeclare it
    
    | Check if item still exists (handle main inventory slots differently)
    /if (${bagNum} == 0) {
        | Main inventory slot (23-32) - use .Name explicitly
        /varset currentItemName ${Me.Inventory[${slotNum}].Name}
        /varset itemValue ${Int[${Math.Calc[${Me.Inventory[${slotNum}].Value} / 1000]}]}
        /varset bankItemLink ${Me.Inventory[${slotNum}].ItemLink[CLICKABLE]}
    } else {
        | Bag slot
        /varset currentItemName ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Name}
        /varset itemValue ${Int[${Math.Calc[${Me.Inventory[pack${bagNum}].Item[${slotNum}].Value} / 1000]}]}
        /varset bankItemLink ${Me.Inventory[pack${bagNum}].Item[${slotNum}].ItemLink[CLICKABLE]}
    }
    /if (!${currentItemName.Length} || ${currentItemName.Equal[NULL]}) /return
    
    | Verify it's the item we expect
    /if (${currentItemName.NotEqual[${itemName}]}) {
        /if (${showDebug}) /echo [BankItem] Item changed: expected ${itemName}, found ${currentItemName}
        /return
    }
    
    | Check if bank window is still open
    /if (!${Window[BigBankWnd].Open}) {
        /call AnnounceBankSell "${tlTag} \arERROR: Bank window closed during bank!"
        /return
    }
    
    | Click item to put on cursor (shift-click to bank)
    /if (${showDebug}) {
        /if (${bagNum} == 0) {
            /echo [BankItem] Attempting to bank ${itemName} (main inventory slot ${slotNum})
        } else {
            /echo [BankItem] Attempting to bank ${itemName} (pack${bagNum}, slot${slotNum})
        }
    }
    
    | Handle occupied cursor gracefully (previous banking may have failed)
    /if (${Cursor.ID}) {
        /if (${showDebug}) /echo [BankItem] Cursor occupied with ${Cursor.Name}, attempting to clear...
        | Try IW_CharacterView first (most reliable)
        /if (!${Window[InventoryWindow].Open}) /keypress i
        /delay 5 ${Window[InventoryWindow].Open}
        /if (${Window[InventoryWindow].Open}) {
            /notify InventoryWindow IW_CharacterView leftmouseup
            /delay 5 !${Cursor.ID}
        }
        | Fallback to /autoinventory
        /if (${Cursor.ID}) {
            /autoinventory
            /delay 5 !${Cursor.ID}
        }
        | If still occupied, warn and skip this item
        /if (${Cursor.ID}) {
            /call AnnounceBankSell "${tlTag} \arWARNING: Could not clear cursor (has: ${Cursor.Name}). Skipping ${itemName}."
            /return
        }
    }
    
    | Shift-click item to put on cursor
    | For main inventory: skip (use bags for banking)
    /if (${bagNum} == 0) {
        | bankItemLink already set at top of subroutine
        /call AnnounceBankSell "${tlTag} \aoNOTICE: Item ${bankItemLink} \aoin main inventory slot ${slotNum} is marked \ayBANK\ao."
        /call AnnounceBankSell "${tlTag} \arACTION REQUIRED: Move ${bankItemLink} \arto a bag (pack1-pack10); then run \ag/mac turboloot bank\ar again to bank it. This is a limitation of MQ."
        /return
    } else {
        | Fast path: non-stackable containers cannot be auto-banked into bank bags. Skip without touching cursor.
        /declare slotContainerSlots int local ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Container}
        /declare slotIsStackable bool local ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Stackable}
        /if (${slotContainerSlots} > 0 && !${slotIsStackable}) {
            /declare warnKey string local ${currentItemName.Upper.Replace[ ,]}
            /if (!${warnKey.Length}) /varset warnKey "UNKNOWNCONTAINER"
            /if (${BankContainerWarnedKeys.Length} > 2000) /varset BankContainerWarnedKeys ""
            /if (!${BankContainerWarnedKeys.Length} || !${BankContainerWarnedKeys.Find[|${warnKey}|]}) {
                /varset BankContainerWarnedKeys "${BankContainerWarnedKeys}|${warnKey}|"
                /call Announce "${announceDefaultTo}" "${tlTag} \ar[ERROR]\aw Cannot auto-bank containers unless there is an open top-level bank slot (outside of bank bags)."
                /call Announce "${announceDefaultTo}" "${tlTag} \ayConsider removing this container from your INI BANK settings: \aw${bankItemLink}"
            }
            /if (${showDebug}) /echo [BankItem] Skipping container before cursor: Name=${currentItemName} Container=${slotContainerSlots} Stackable=${slotIsStackable}
            /return
        }
        /nomodkey /shift /itemnotify in pack${bagNum} ${slotNum} leftmouseup
    }
    
    | Wait briefly for item to be on cursor (or quantity window to appear)
    /delay 10 ${Cursor.ID} || ${Window[QuantityWnd].Open}
    
    | Handle quantity window if it opens (for stackable items)
    /if (${Window[QuantityWnd].Open}) {
        /notify QuantityWnd QTYW_Accept_Button leftmouseup
        /delay 5 !${Window[QuantityWnd].Open}
    }
    
    | If item still isn't on cursor, retry click once (fast), then wait again
    /if (!${Cursor.ID}) {
        /nomodkey /shift /itemnotify in pack${bagNum} ${slotNum} leftmouseup
        /delay 10 ${Cursor.ID}
    }
    
    /if (!${Cursor.ID}) {
        /if (${showDebug}) /echo [BankItem] Item did not move to cursor: ${itemName}
        /return
    }
    
    | Check if item is a container BEFORE attempting to bank (containers often fail)
    /declare isContainer bool local FALSE
    /declare cursorInfo string local "Name: ${Cursor.Name} | Container: ${Cursor.Container} | Stackable: ${Cursor.Stackable} | Lore: ${Cursor.Lore} | NoDrop: ${Cursor.NoDrop}"
    /if (${Cursor.Container} > 0) /varset isContainer TRUE
    /if (${showDebug}) /echo [BankItem] Item on cursor: ${cursorInfo} (isContainer: ${isContainer})
    
    | Click auto-deposit button
    /notify BigBankWnd BIGB_AutoButton leftmouseup
    
    | Wait for cursor to settle after auto-deposit:
    | - Success: cursor clears (Cursor.ID becomes empty)
    | - Failure: cursor name returns quickly (Cursor.Name.Length becomes true)
    /if (${isContainer}) {
        /delay 10 !${Cursor.ID} || ${Cursor.Name.Length}
    } else {
        /delay 20 !${Cursor.ID} || ${Cursor.Name.Length}
    }
    
    /if (${showDebug}) /echo [BankItem] After Auto-Bank: Cursor.ID=${Cursor.ID}, Cursor.Name=${Cursor.Name}
    
    | Check if cursor is empty - that's the true indicator of success
    | (Item may be gone from slot because it's on cursor, not because it was banked)
    /if (!${Cursor.ID}) {
        /varcalc itemsBanked ${itemsBanked} + 1
        /call AnnounceBankSell "${tlTag} \ap[BANK]\aw ${bankItemLink}"
        /return
    }

    | Cursor still has item - banking failed
    /if (${showDebug}) /echo [BankItem] Banking failed - cursor still has item. isContainer=${isContainer}

    | Special case: If container is stackable, it MIGHT be able to auto-deposit into an existing bank stack.
    | Try one extra quick auto-deposit attempt, then bail out if it still fails.
    /if (${isContainer} && ${Cursor.Stackable}) {
        /if (${showDebug}) /echo [BankItem] Container is stackable; trying one extra quick auto-deposit: ${cursorInfo}
        /notify BigBankWnd BIGB_AutoButton leftmouseup
        /delay 10 !${Cursor.ID} || ${Cursor.Name.Length}
        /if (!${Cursor.ID}) {
            /varcalc itemsBanked ${itemsBanked} + 1
            /call AnnounceBankSellPerItem "${tlTag} \ap[BANK]\aw ${bankItemLink}"
            /return
        }
    }

    | If container, don't retry (it won't work), just return to inventory
    /if (${isContainer}) {
        /declare warnKey string local ${Cursor.Name.Upper.Replace[ ,]}
        /if (!${warnKey.Length}) /varset warnKey "UNKNOWNCONTAINER"
        /if (${BankContainerWarnedKeys.Length} > 2000) /varset BankContainerWarnedKeys ""
        /if (!${BankContainerWarnedKeys.Length} || !${BankContainerWarnedKeys.Find[|${warnKey}|]}) {
            /varset BankContainerWarnedKeys "${BankContainerWarnedKeys}|${warnKey}|"
            /call Announce "${announceDefaultTo}" "${tlTag} \ar[ERROR]\aw Cannot auto-bank containers unless there is an open top-level bank slot (outside of bank bags)."
            /call Announce "${announceDefaultTo}" "${tlTag} \ayConsider removing this container from your INI BANK settings: \aw${bankItemLink}"
        }
        /if (${showDebug}) /echo [BankItem] Container autobank failed: ${cursorInfo}
        | Try multiple methods to return item to inventory
        | Method 1: Click the character model/class icon area in inventory window (most reliable)
        /if (!${Window[InventoryWindow].Open}) /keypress i
        /delay 5 ${Window[InventoryWindow].Open}
        /if (${Window[InventoryWindow].Open}) {
            /notify InventoryWindow IW_CharacterView leftmouseup
            /delay 5 !${Cursor.ID}
        }
        | Method 2: /autoinventory as fallback
        /if (${Cursor.ID}) {
            /autoinventory
            /delay 5 !${Cursor.ID}
        }
        | Method 3: Click back on the original bag slot
        /if (${Cursor.ID} && ${bagNum} > 0) {
            /nomodkey /itemnotify in pack${bagNum} ${slotNum} leftmouseup
            /delay 5 !${Cursor.ID}
        }
        /if (${Cursor.ID}) {
            /call AnnounceBankSell "${tlTag} \arWARNING: Item still on cursor: \aw${Cursor.Name}\ar. Please clear manually."
        }
        /return
    }
    
    | Non-container: Item still on cursor, try auto-deposit again
    /if (${Cursor.ID} && ${Cursor.Name.Equal[${itemName}]}) {
        /if (${showDebug}) /echo [BankItem] Item still on cursor, attempting auto-deposit again...
        /notify BigBankWnd BIGB_AutoButton leftmouseup
        
        | Wait again (short) for cursor to settle
        /delay 20 !${Cursor.ID} || ${Cursor.Name.Length}
        
        | Check if cursor is now empty (success)
        /if (!${Cursor.ID}) {
            /varcalc itemsBanked ${itemsBanked} + 1
            /call AnnounceBankSellPerItem "${tlTag} \ap[BANK]\aw ${bankItemLink}"
            /return
        }
    }
    
    | Item still on cursor after all attempts - return to inventory to avoid stuck cursor
    /if (${Cursor.ID}) {
        /call AnnounceBankSell "${tlTag} \arERROR: Banking failed for \aw${itemName}\ar. Returning to inventory."
        | Try multiple methods to return item to inventory
        | Method 1: Click the character model/class icon area in inventory window
        /if (!${Window[InventoryWindow].Open}) /keypress i
        /delay 5 ${Window[InventoryWindow].Open}
        /if (${Window[InventoryWindow].Open}) {
            /notify InventoryWindow IW_CharacterView leftmouseup
            /delay 5 !${Cursor.ID}
        }
        | Method 2: /autoinventory as fallback
        /if (${Cursor.ID}) {
            /autoinventory
            /delay 5 !${Cursor.ID}
        }
        | Method 3: Click back on the original bag slot
        /if (${Cursor.ID} && ${bagNum} > 0) {
            /nomodkey /itemnotify in pack${bagNum} ${slotNum} leftmouseup
            /delay 5 !${Cursor.ID}
        }
        /if (${Cursor.ID}) {
            /call AnnounceBankSell "${tlTag} \arWARNING: Item still on cursor: \aw${Cursor.Name}\ar. Please clear manually."
        }
        /return
    }
/return
|| ---------------------------------------------------------------------
|| SELL ITEM (helper subroutine)
|| ---------------------------------------------------------------------
Sub SellItem(int bagNum, int slotNum, string itemName)
    | Use outer variables (declared in InitState)
    /declare sellingItemText string local
    /declare currentItemName string local
    /declare sellItemLink string local

    /declare stackCount int local 1
    /declare perItemCopper int local 0
    /declare totalStackCopper int local 0
    /declare totalStackPP int local 0

    | --- Read item, stack count, and value ---
    | NOTE: .Value is the value of ONE item (in copper). For stacks, multiply by .Stack.
    /if (${bagNum} == 0) {
        | Main inventory slot (23-32)
        /varset currentItemName ${Me.Inventory[${slotNum}].Name}
        /varset sellItemLink ${Me.Inventory[${slotNum}].ItemLink[CLICKABLE]}

        /if (${Me.Inventory[${slotNum}].Stackable}) /varset stackCount ${Me.Inventory[${slotNum}].Stack}
        /varset perItemCopper ${Me.Inventory[${slotNum}].Value}
    } else {
        | Bag slot
        /varset currentItemName ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Name}
        /varset sellItemLink ${Me.Inventory[pack${bagNum}].Item[${slotNum}].ItemLink[CLICKABLE]}

        /if (${Me.Inventory[pack${bagNum}].Item[${slotNum}].Stackable}) /varset stackCount ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Stack}
        /varset perItemCopper ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Value}
    }
    | --- DEBUG: raw MQ2 values ---
    /if (${showDebug}) {
        /if (${bagNum} == 0) {
            /echo [SellDBG] bag=${bagNum} slot=${slotNum} want=${itemName}
            /echo [SellDBG] have=${Me.Inventory[${slotNum}].Name}
            /echo [SellDBG] value=${Me.Inventory[${slotNum}].Value}
            /echo [SellDBG] stack=${Me.Inventory[${slotNum}].Stack} stackable=${Me.Inventory[${slotNum}].Stackable}
        } else {
            /echo [SellDBG] bag=${bagNum} slot=${slotNum} want=${itemName}
            /echo [SellDBG] have=${Me.Inventory[pack${bagNum}].Item[${slotNum}].Name}
            /echo [SellDBG] value=${Me.Inventory[pack${bagNum}].Item[${slotNum}].Value}
            /echo [SellDBG] stack=${Me.Inventory[pack${bagNum}].Item[${slotNum}].Stack} stackable=${Me.Inventory[pack${bagNum}].Item[${slotNum}].Stackable}
        }
    }


    /if (!${currentItemName.Length} || ${currentItemName.Equal[NULL]}) /return

    | Verify it's the item we expect
    /if (${currentItemName.NotEqual[${itemName}]}) {
        /if (${showDebug}) /echo [SellItem] Item changed: expected ${itemName}, found ${currentItemName}
        /return
    }

    | Total value for the whole stack (copper) and whole-plat display value
    /varset totalStackCopper ${Math.Calc[${perItemCopper}*${stackCount}]}
    /varset totalStackPP ${Int[${Math.Calc[${totalStackCopper}/1000]}]}

    | Use totalStackPP for the "can it be sold" check
    /varset itemValue ${totalStackPP}

    | Check item value - items with 0 value can't be sold to merchants
    /if (${perItemCopper} <= 0) {
        /if (${showDebug}) /echo [SellItem] Skipping ${itemName} - value is 0 (items with 0 value cannot be sold)
        /return
    }

    | Check if merchant window is still open
    /if (!${Window[MerchantWnd].Open}) {
        /call AnnounceBankSell "${tlTag} \arERROR: Merchant window closed during sell!"
        /return
    }

    | MQ2 limitation: reliably selling from main inventory while MerchantWnd is open is flaky.
    | Force user to move SELL items into bags.
    /if (${bagNum} == 0) {
        /call AnnounceBankSell "${tlTag} \aoNOTICE/ACTION REQUIRED:\aw ${sellItemLink} \aoin main inventory slot ${slotNum} is marked \agSELL\ao. \arMove it to a bag, then run \ag/mac turboloot sell\ar again. \ay(MQ limitation)\ax"
        /return
    }

    | Handle occupied cursor gracefully
    /if (${Cursor.ID}) {
        /if (${showDebug}) /echo [SellItem] Cursor occupied, attempting to clear...
        /autoinventory
        /delay 10 !${Cursor.ID}
    }

    | Click item in bag to select it in merchant window
    /nomodkey /itemnotify in pack${bagNum} ${slotNum} leftmouseup

    | Handle quantity window if it opens (for stackable items)
    /if (${Window[QuantityWnd].Open}) {
        /notify QuantityWnd QTYW_Accept_Button leftmouseup
        /delay 5 !${Window[QuantityWnd].Open}
    }
    
    
    | Verify merchant selected it
    /delay 5 ${Window[MerchantWnd].Child[MW_SelectedItemLabel].Text.Equal[${itemName}]}
    /varset sellingItemText ${Window[MerchantWnd].Child[MW_SelectedItemLabel].Text}
    /if (${sellingItemText.NotEqual[${itemName}]}) {
        /call AnnounceBankSell "${tlTag} \arERROR: Cannot get merchant to select item: \aw${itemName}"
        /return
    }

    | Check if sell button is enabled
    /if (!${Window[MerchantWnd].Child[MW_Sell_Button].Enabled}) {
        /if (${showDebug}) /echo [SellItem] Sell button not enabled for ${itemName} - skipping
        /return
    }
    
    | Snapshot coins BEFORE selling (copper units)
    /declare beforeCopper int local ${Math.Calc[${Me.Platinum}*1000+${Me.Gold}*100+${Me.Silver}*10+${Me.Copper}]}
    
    | Click sell button with shift modifier
    /nomodkey /shift /notify MerchantWnd MW_Sell_Button leftmouseup

    | Wait for item to be sold (slot empty or different item)
    /declare waitSold int local 0
    /declare slotItemName string local
    /while (${waitSold} < 100) {
        /varset slotItemName ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Name}
        /if (${slotItemName.Equal[NULL]} || !${slotItemName.Length} || ${slotItemName.NotEqual[${itemName}]}) /break
        /varcalc waitSold ${waitSold} + 1
        /delay 1
    }

    | Verify merchant window is still open
    /if (!${Window[MerchantWnd].Open}) {
        /call AnnounceBankSell "${tlTag} \arERROR: Merchant window closed during sell!"
        /return
    }

    | Verify item was sold
    /varset currentItemName ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Name}
    /if (${currentItemName.Equal[NULL]} || !${currentItemName.Length} || ${currentItemName.NotEqual[${itemName}]}) {
        /delay 1
        | Snapshot coins AFTER selling (copper units) and compute delta
        /declare afterCopper int local ${Math.Calc[${Me.Platinum}*1000+${Me.Gold}*100+${Me.Silver}*10+${Me.Copper}]}
        /declare gainedCopper int local ${Math.Calc[${afterCopper}-${beforeCopper}]}
        /if (${showDebug}) /echo [SellDBG] gainedCopper=${gainedCopper}
        /if (${showDebug}) /echo [SellDBG] estCopper=${totalStackCopper} gainedCopper=${gainedCopper}
    
        | Increment totals:
        | - itemsSold counts each unit in stack as 1
        | - sellTotalCopper counts full stack value (per-item copper * stack)
        /varcalc itemsSold ${itemsSold} + ${stackCount}
        /varcalc sellTotalCopper ${sellTotalCopper} + ${gainedCopper}
        
        | Keep platinumGain as whole platinum (based on actual gained copper)
        /varcalc platinumGain ${platinumGain} + ${Int[${Math.Calc[${gainedCopper}/1000]}]}

        | Build per-sell currency text (pp gp sp cp)
        /declare p int local ${Int[${Math.Calc[${gainedCopper}/1000]}]}
        /declare g int local ${Int[${Math.Calc[(${gainedCopper}%1000)/100]}]}
        /declare s int local ${Int[${Math.Calc[(${gainedCopper}%100)/10]}]}
        /declare c int local ${Int[${Math.Calc[${gainedCopper}%10]}]}

        /if (${showDebug} || ${announceLooted}) {
            /call AnnounceBankSell "${tlTag} \ag[SELL] ${sellItemLink} \aw(x${stackCount}) \awfor \ag${p}pp ${g}gp ${s}sp ${c}cp\ag \au"
        }
        /return
    }

    | Item still in inventory - error
    /call AnnounceBankSell "${tlTag} \arERROR: Selling item failed. Item:\aw${itemName} \arStill in inventory. pack:\aw${bagNum} \arslot:\aw${slotNum}"
    /if (${showDebug}) {
        /call AnnounceBankSell "${tlTag} \arDEBUG: Sell button enabled: ${Window[MerchantWnd].Child[MW_Sell_Button].Enabled}"
        /call AnnounceBankSell "${tlTag} \arDEBUG: Merchant selected item: ${Window[MerchantWnd].Child[MW_SelectedItemLabel].Text}"
        /call AnnounceBankSell "${tlTag} \arDEBUG: Current item in slot: ${currentItemName}"
    }
/return

||| ---------------------------------------------------------------------
||| TRIBUTE ITEM (helper subroutine)
||| ---------------------------------------------------------------------
Sub TributeItem(int bagNum, int slotNum, string itemName)
    | ---------- Locals (declare once = bulletproof) ----------
    /declare currentItemName string local
    /declare tributeItemLink string local
    /declare tributeValue int local 0
    /declare tributeItemID int local 0
    /declare originalStackSize int local 0
    /declare beforeStack int local 0
    /declare afterStack int local 0
    /declare afterSlotID int local 0

    /declare beforeInv int local 0
    /declare afterInv int local 0
    /declare tributedUnits int local 0

    /declare beforeTP int local 0
    /declare afterTP int local 0
    /declare gainedTP int local 0

    /declare announceTP int local 0
    /declare pointsToAdd int local 0

    | ---------- Read item info ----------
    /if (${bagNum} == 0) {
        | Main inventory slot (23-32)
        /varset currentItemName ${Me.Inventory[${slotNum}].Name}
        /varset tributeItemID ${Me.Inventory[${slotNum}].ID}
        /varset tributeValue ${Me.Inventory[${slotNum}].Tribute}
        /varset tributeItemLink ${Me.Inventory[${slotNum}].ItemLink[CLICKABLE]}
    } else {
        | Bag slot
        /varset currentItemName ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Name}
        /varset tributeItemID ${Me.Inventory[pack${bagNum}].Item[${slotNum}].ID}
        /varset tributeValue ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Tribute}
        /varset tributeItemLink ${Me.Inventory[pack${bagNum}].Item[${slotNum}].ItemLink[CLICKABLE]}
    
        | Reset stack tracking (prevents leakage from previous items)
        /varset originalStackSize 0
        /varset beforeStack 0
        /varset afterStack 0
    
        | Capture BEFORE stack size (for stack delta)
        /if (${Me.Inventory[pack${bagNum}].Item[${slotNum}].ID} && ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Stackable}) {
            /varset originalStackSize ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Stack}
            /varset beforeStack ${originalStackSize}
        }
    }

    /if (!${currentItemName.Length} || ${currentItemName.Equal[NULL]}) /return

    | Verify it's the item we expect
    /if (${currentItemName.NotEqual[${itemName}]}) {
        /if (${showDebug}) /echo [TributeItem] Item changed: expected ${itemName}, found ${currentItemName}
        /return
    }

    | Check tribute window
    /if (!${Window[TributeMasterWnd].Open}) {
        /call AnnounceBankSell "${tlTag} \arERROR: Tribute window closed during tribute!"
        /return
    }

    | Check item has tribute value
    /if (${tributeValue} <= 0) {
        /if (${showDebug}) /echo [TributeItem] Skipping ${itemName} - tribute value is ${tributeValue}
        /return
    }

    | Main inventory items must be moved into a bag
    /if (${bagNum} == 0) {
        /call AnnounceBankSell "${tlTag} \aoNOTICE: Item ${tributeItemLink} \aoin main inventory slot ${slotNum} is marked \ayTRIBUTE\ao."
        /call AnnounceBankSell "${tlTag} \arACTION REQUIRED: Move ${tributeItemLink} \arto a bag (pack1-pack10); then run \ag/mac turboloot tribute\ar again to tribute it. This is a limitation of MQ."
        /return
    }

    /if (${showDebug}) /echo [TributeItem] Attempting to tribute ${itemName} (pack${bagNum}, slot${slotNum})

    | ---------- Delta snapshots BEFORE donating ----------
    /varset beforeInv ${FindItemCount[=${itemName}]}
    /varset beforeTP ${Me.CurrentFavor}

    | Load item + donate (supports UI variants + stack quantity)
    /declare tries int local 0
    /declare waitDonate int local 0
    /declare clickedDonate bool local FALSE
    /while ((${tries} < 4) && (!${clickedDonate})) {
        | Safety: slot content can change as items move; never risk donating the wrong item
        /if (!${Me.Inventory[pack${bagNum}].Item[${slotNum}].ID} || ${Me.Inventory[pack${bagNum}].Item[${slotNum}].ID} != ${tributeItemID}) {
            /call AnnounceBankSell "${tlTag} \aoWARNING: Tribute slot changed before donating. Expected id=${tributeItemID} but found id=${Me.Inventory[pack${bagNum}].Item[${slotNum}].ID} in pack${bagNum} slot${slotNum}. Skipping to avoid donating the wrong item."
            /return
        }

        | Tribute selection can be flaky unless the bag window is open (UI/client dependent)
        /if (!${Window[pack${bagNum}].Open}) {
            /nomodkey /itemnotify pack${bagNum} rightmouseup
            /delay 2 ${Window[pack${bagNum}].Open}
        }

        | Ensure cursor is clear before interacting with the tribute UI
        /if (${Cursor.ID}) /call ClearCursor

        | Click item to load into tribute window
        /nomodkey /itemnotify in pack${bagNum} ${slotNum} leftmouseup
        /delay 2 ${Window[QuantityWnd].Open}

        | Quantity window can appear on select for some stackables
        /if (${Window[QuantityWnd].Open}) {
            /notify QuantityWnd QTYW_Accept_Button leftmouseup
            /delay 5 !${Window[QuantityWnd].Open}
        }

        | Wait briefly for Donate to become enabled, then click it
        /varset waitDonate 0
        /while ((${waitDonate} < 10) && (!${clickedDonate})) {
            /call IsTributeDonateEnabled
            /if (${Macro.Return}) {
                | Safety: re-check slot hasn't changed right before clicking Donate
                /if (!${Me.Inventory[pack${bagNum}].Item[${slotNum}].ID} || ${Me.Inventory[pack${bagNum}].Item[${slotNum}].ID} != ${tributeItemID}) {
                    /call AnnounceBankSell "${tlTag} \aoWARNING: Tribute slot changed while waiting to donate. Expected id=${tributeItemID} but found id=${Me.Inventory[pack${bagNum}].Item[${slotNum}].ID} in pack${bagNum} slot${slotNum}. Skipping to avoid donating the wrong item."
                    /return
                }
                /call TryClickTributeDonateButton
                /if (${Macro.Return}) /varset clickedDonate TRUE
            } else {
                /delay 1
            }
            /varcalc waitDonate ${waitDonate} + 1
        }

        /varcalc tries ${tries} + 1
        /delay 1
    }

    /if (!${clickedDonate}) {
        /call AnnounceBankSell "${tlTag} \aoWARNING: Cannot tribute ${tributeItemLink} \ao(Donate never enabled). pack${bagNum} slot${slotNum} id=${tributeItemID} tributeValue=${tributeValue}. Skipping this item."
        /return
    }

    | Handle quantity window if it opens (for stackable items)
    /if (${Window[QuantityWnd].Open}) {
        /notify QuantityWnd QTYW_Accept_Button leftmouseup
        /delay 5 !${Window[QuantityWnd].Open}
    }

    /delay 1

   | Wait (briefly) for favor to update (exits early if it changes)
   /declare waitTP int local 0
   /while ((${waitTP} < 20) && (${Me.CurrentFavor} == ${beforeTP})) {
       /delay 1
       /varcalc waitTP ${waitTP} + 1
   }
   
    | ---------- Delta snapshots AFTER donating ----------
    | Capture stack size after donating (if stackable)
    /if (${Me.Inventory[pack${bagNum}].Item[${slotNum}].Stackable}) {
        /varset afterStack ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Stack}
    }

    /varset afterSlotID ${Me.Inventory[pack${bagNum}].Item[${slotNum}].ID}
    
    | Prefer slot stack delta first (most reliable for stack donations)
    /if (${beforeStack} > 0 && ${afterStack} > 0 && ${afterStack} < ${beforeStack}) {
        /varset tributedUnits ${Math.Calc[${beforeStack}-${afterStack}]}
    }
    
    /varset afterInv ${FindItemCount[=${itemName}]}
    /varset afterTP ${Me.CurrentFavor}
    
    | If stack delta didn't tell us units, fall back to FindItemCount delta
    /if (${tributedUnits} <= 0) /varset tributedUnits ${Math.Calc[${beforeInv}-${afterInv}]}
    /if (${tributedUnits} < 0) /varset tributedUnits 0
    
    /if (${tributedUnits} < 0) /varset tributedUnits 0

    /varset gainedTP ${Math.Calc[${afterTP}-${beforeTP}]}
    /if (${gainedTP} < 0) /varset gainedTP 0

    | Debug (optional)
    /if (${showDebug}) /echo [TribDBG] item=${itemName} beforeInv=${beforeInv} afterInv=${afterInv} beforeTP=${beforeTP} afterTP=${afterTP} units=${tributedUnits} gainedTP=${gainedTP}

    | ---------- Decide success ----------
    | If units decreased OR favor increased, we treat it as success.
    /if (${tributedUnits} > 0 || ${gainedTP} > 0) {

        | If the slot item changed/cleared but our unit delta missed it, assume 1 unit for non-stackables
        /if (${tributedUnits} <= 0 && ${afterSlotID} != ${tributeItemID} && ${tributeItemID} > 0) /varset tributedUnits 1

        | Prefer actual gainedTP; otherwise estimate from tributeValue * units
        /varset pointsToAdd ${gainedTP}
        /if (${pointsToAdd} <= 0) {
            /if (${tributedUnits} > 0) {
                /varset pointsToAdd ${Math.Calc[${tributeValue}*${tributedUnits}]}
            } else {
                /varset pointsToAdd ${tributeValue}
            }
        }

        | Update run totals (outer vars)
        /varcalc tributeItemsMoved ${tributeItemsMoved} + ${tributedUnits}
        /varcalc tributePointsGained ${tributePointsGained} + ${pointsToAdd}

        | Keep your existing counter (per action, not per unit)
        /varcalc itemsTributed ${itemsTributed} + 1

        /varset announceTP ${pointsToAdd}

        /call AnnounceBankSell "${tlTag} \ay[TRIBUTE]\aw ${tributeItemLink} \at(+${announceTP} TP)"
        /return
    }

    | ---------- If we get here, delta says nothing changed ----------
    /call AnnounceBankSell "${tlTag} \aoWARNING: Tribute for ${tributeItemLink} did not show an immediate delta (inv/favor unchanged). If this item should tribute - try again or increase delay."
/return

|| ---------------------------------------------------------------------
|| DESTROY ITEM (helper subroutine)
|| ---------------------------------------------------------------------
Sub DestroyItem(int bagNum, int slotNum, string itemName)
    /declare currentItemName string local
    /declare destroyItemLink string local
    /declare destroyItemID int local 0
    /declare destroyUnits int local 1
    /declare pickupTries int local 0
    /declare waitPick int local 0

    | Main inventory items must be moved into a bag for reliable /itemnotify handling
    /if (${bagNum} == 0) {
        /declare mainLink string local ${Me.Inventory[${slotNum}].ItemLink[CLICKABLE]}
        /call AnnounceBankSell "${tlTag} \aoNOTICE/ACTION REQUIRED:\aw ${mainLink} \aoin main inventory slot ${slotNum} is marked \arDESTROY\ao. \arMove it to a bag (pack1-pack10), then run \ag/mac turboloot destroy\ar. \ay(MQ limitation)\ax"
        /return
    }

    /varset currentItemName ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Name}
    /varset destroyItemID ${Me.Inventory[pack${bagNum}].Item[${slotNum}].ID}
    /varset destroyItemLink ${Me.Inventory[pack${bagNum}].Item[${slotNum}].ItemLink[CLICKABLE]}
    /varset destroyUnits 1
    /if (${Me.Inventory[pack${bagNum}].Item[${slotNum}].Stackable}) /varset destroyUnits ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Stack}
    /if (${destroyUnits} <= 0) /varset destroyUnits 1
    /if (!${currentItemName.Length} || ${currentItemName.Equal[NULL]} || !${destroyItemID}) /return

    | Verify it's the item we expect
    /if (${currentItemName.NotEqual[${itemName}]}) {
        /if (${showDebug}) /echo [DestroyItem] Item changed: expected ${itemName}, found ${currentItemName}
        /return
    }

    | Ensure the bag window is open so /itemnotify works
    /if (!${Window[pack${bagNum}].Open}) {
        /nomodkey /itemnotify pack${bagNum} rightmouseup
        /delay 2 ${Window[pack${bagNum}].Open}
    }

    | Pick up item onto cursor (shift-click) with a couple retries (UI lag can delay Cursor.ID)
    /varset pickupTries 0
    :tryPickupForDestroy
    /varcalc pickupTries ${pickupTries} + 1

    | Ensure cursor is clear before picking up the item
    /if (${Cursor.ID}) /call ClearCursor
    /delay 5 !${Cursor.ID}
    /if (${Cursor.ID}) {
        /call AnnounceBankSell "${tlTag} \arWARNING: Could not clear cursor (has: \aw${Cursor.Name}\ar). Skipping destroy of \aw${destroyItemLink}\ar."
        /return
    }

    /nomodkey /shift /itemnotify in pack${bagNum} ${slotNum} leftmouseup

    /varset waitPick 0
    /while (${waitPick} < 20 && !${Cursor.ID}) {
        /doevents
        /if (${Window[QuantityWnd].Open}) /call HandleQuantityWindow
        /if (${Cursor.ID}) /break
        /delay 1
        /varcalc waitPick ${waitPick} + 1
    }

    /if (!${Cursor.ID}) {
        | One more (or two) pickup attempts before giving up
        /if (${pickupTries} < 3) /goto :tryPickupForDestroy
        /call AnnounceBankSell "${tlTag} \arWARNING: Could not pick up \aw${destroyItemLink}\ar to cursor (UI lag). Skipping this item for now."
        /return
    }

    | Safety: ensure we picked up the expected item ID
    /if (${Cursor.ID} != ${destroyItemID}) {
        /call AnnounceBankSell "${tlTag} \aoWARNING: Cursor item changed unexpectedly while destroying. Expected id=${destroyItemID} but got id=${Cursor.ID}. Clearing cursor to avoid destroying the wrong item."
        /call ClearCursor
        /return
    }
    | Prefer the cursor stack size (what will actually be destroyed)
    /if (${Cursor.Stackable}) /varset destroyUnits ${Cursor.Stack}
    /if (${destroyUnits} <= 0) /varset destroyUnits 1

    /call AnnounceBankSellPerItem "${tlTag} \ar[DESTROY]\aw ${destroyItemLink} \aw(x${destroyUnits})"

    /destroy
    /delay 10 !${Cursor.ID}
    /if (${Cursor.ID}) {
        | One more attempt
        /destroy
        /delay 10 !${Cursor.ID}
    }

    /if (${Cursor.ID}) {
        /call AnnounceBankSell "${tlTag} \arWARNING: Destroy failed; item still on cursor: \aw${Cursor.Name}\ar. Please clear manually."
        /return
    }

    /varcalc itemsDestroyed ${itemsDestroyed} + ${destroyUnits}
    /call AnnounceBankSellPerItem "${tlTag} \ar[DESTROY]\aw ${destroyItemLink} \aw(x${destroyUnits})"
/return

| ---------------------------------------------------------------------
| TRY CLICK TRIBUTE DONATE (UI-safe helpers)
| ---------------------------------------------------------------------
Sub IsTributeDonateEnabled
    | Returns 1 if any known Donate button is enabled, else 0
    /if (${Window[TributeMasterWnd].Child[TMW_DonateButton]}) {
        /if (${Window[TributeMasterWnd].Child[TMW_DonateButton].Enabled}) /return 1
    }
    /if (${Window[TributeMasterWnd].Child[DonateButton]}) {
        /if (${Window[TributeMasterWnd].Child[DonateButton].Enabled}) /return 1
    }
    /if (${Window[TributeMasterWnd].Child[TMW_Donate_Button]}) {
        /if (${Window[TributeMasterWnd].Child[TMW_Donate_Button].Enabled}) /return 1
    }
    /if (${Window[TributeMasterWnd].Child[TMW_DonateItem_Button]}) {
        /if (${Window[TributeMasterWnd].Child[TMW_DonateItem_Button].Enabled}) /return 1
    }
    /if (${Window[TributeMasterWnd].Child[TMW_DonateItemButton]}) {
        /if (${Window[TributeMasterWnd].Child[TMW_DonateItemButton].Enabled}) /return 1
    }
    /return 0

Sub TryClickTributeDonateButton
    | Returns 1 if a known Donate button was clicked, else 0
    /if (${Window[TributeMasterWnd].Child[TMW_DonateButton]}) {
        /if (${Window[TributeMasterWnd].Child[TMW_DonateButton].Enabled}) {
            /notify TributeMasterWnd TMW_DonateButton leftmouseup
            /return 1
        }
    }
    /if (${Window[TributeMasterWnd].Child[DonateButton]}) {
        /if (${Window[TributeMasterWnd].Child[DonateButton].Enabled}) {
            /notify TributeMasterWnd DonateButton leftmouseup
            /return 1
        }
    }
    /if (${Window[TributeMasterWnd].Child[TMW_Donate_Button]}) {
        /if (${Window[TributeMasterWnd].Child[TMW_Donate_Button].Enabled}) {
            /notify TributeMasterWnd TMW_Donate_Button leftmouseup
            /return 1
        }
    }
    /if (${Window[TributeMasterWnd].Child[TMW_DonateItem_Button]}) {
        /if (${Window[TributeMasterWnd].Child[TMW_DonateItem_Button].Enabled}) {
            /notify TributeMasterWnd TMW_DonateItem_Button leftmouseup
            /return 1
        }
    }
    /if (${Window[TributeMasterWnd].Child[TMW_DonateItemButton]}) {
        /if (${Window[TributeMasterWnd].Child[TMW_DonateItemButton].Enabled}) {
            /notify TributeMasterWnd TMW_DonateItemButton leftmouseup
            /return 1
        }
    }
    /return 0

| ---------------------------------------------------------------------
| PROCESS LOOT ITEM (normal INI-driven looting)
| ---------------------------------------------------------------------
Sub ProcessLootItem(int lootSlot, string limitParam)
    /declare thisName string local
    
    /varset thisName ${Corpse.Item[${lootSlot}].Name}
    /if (!${thisName.Length} || ${thisName.Equal[NULL]} || ${thisName.Equal[null]}) {
        /if (${showDebug}) /echo [turboLoot] ERROR: Cannot get item name for slot ${lootSlot} in ProcessLootItem
        /return
    }
    /varset itemLimitUpper ${limitParam.Upper}
    /varset itemLimitUpper ${itemLimitUpper.Replace[ ,]}
    /if (${itemLimitUpper.Equal[SKIP]}) /varset itemLimitUpper IGNORE

    | Unlisted (empty/0/NOTFOUND/NULL): announce skip and return
    /if (!${itemLimitUpper.Length} || ${itemLimitUpper.Equal[0]} || ${itemLimitUpper.Equal[NOTFOUND]} || ${itemLimitUpper.Equal[NULL]}) {
        /call AnnounceSkipped "${Target.ID}:${lootSlot}:${thisName}" "${tlTag} \ao[SKIP] ${Corpse.Item[${lootSlot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID}) \at(unlisted)"
        /return
    }

    /if (${showDebug}) /echo [ProcessLootItem] Processing ${thisName} with limit: "${limitParam}" - Lore: ${Corpse.Item[${lootSlot}].Lore}
    /if (${showDebug} && ${itemLimitUpper.Equal[SELL]}) /echo [DEBUG] ProcessLootItem received SELL item ${thisName} - limitParam="${limitParam}" itemLimitUpper="${itemLimitUpper}"

    /if (${itemLimitUpper.Equal[IGNORE]}) {
        /if (${showDebug}) {
            /if (${announceMethod.Upper.Equal[ECHO]} || ${announceMethod.Upper.Equal[E3BC]}) {
                /docommand /${announceMethod} ${tlTag} \aw[IGNORE] ${Corpse.Item[${lootSlot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID})
            } else {
                /declare msg string local ${tlTag} \aw[IGNORE] ${Corpse.Item[${lootSlot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID})
                /varset msg ${msg.Replace[NULL,${thisName}]}
                /varset msg ${msg.Replace[null,${thisName}]}
                /declare formattedMsg string local ${FormatMessage[${msg},${announceMethod}]}
                /docommand /${announceMethod} ${formattedMsg}
            }
        }
        /varcalc itemsIgnored ${itemsIgnored}+1
        /return
    }

    /if (${itemLimitUpper.Equal[DESTROY]}) {
        /call LootAndDestroyCorpseItem ${lootSlot} "${thisName}"
        /return
    }

    | Check LORE restrictions before SELL/KEEP/BANK
    /if (${Corpse.Item[${lootSlot}].Lore}) {
        /varset currentCount ${Math.Calc[${FindItemCount[=${thisName}]}+${FindItemBankCount[=${thisName}]}]}
        /if (${showDebug}) /echo [ProcessLootItem] LORE item check - currentCount: ${currentCount}
        /if (${currentCount} >= 1) {
            /call AnnounceSkipped "${Target.ID}:${lootSlot}:${thisName}" "${tlTag} \ao[SKIP] ${Corpse.Item[${lootSlot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID}) - Already have"
            /if (${showDebug} && (${thisName.Find[Spell]} || ${thisName.Find[Skill]})) /echo [DEBUG] Wildcard item skipped due to LORE - already have ${currentCount}
            /return
        }
    }

    | SELL/KEEP/BANK/TRIBUTE: loot like ALL
    /if (${itemLimitUpper.Equal[SELL]} || ${itemLimitUpper.Equal[KEEP]} || ${itemLimitUpper.Equal[BANK]} || ${itemLimitUpper.Equal[TRIBUTE]}) {
        /if (${showDebug}) /echo [ProcessLootItem] ItemLimit is ${itemLimitUpper}, treating as ALL for looting
        /call CheckInventorySpace "${thisName}" ${lootSlot}
        /call LootTheItem ${lootSlot} "${thisName}" 999999 "${limitParam}"
        /return
    }

    /if (${itemLimitUpper.Equal[ALL]}) {
        /if (${showDebug}) /echo [ProcessLootItem] ItemLimit is ALL, calling LootTheItem
        /call CheckInventorySpace "${thisName}" ${lootSlot}
        /call LootTheItem ${lootSlot} "${thisName}" 999999 "${limitParam}"
        /return
    }

    /if (!${itemLimitUpper.Equal[ALL]} && !${itemLimitUpper.Equal[IGNORE]} && !${itemLimitUpper.Equal[DESTROY]} && ${Int[${limitParam}]} > 0) {
        /varset currentCount ${Math.Calc[${FindItemCount[=${thisName}]}+${FindItemBankCount[=${thisName}]}]}
        /if (${showDebug}) /echo [ProcessLootItem] Checking limit (inv+bank) - currentCount: ${currentCount}, limitParam: ${limitParam}, Int[limitParam]: ${Int[${limitParam}]}
        /if (${currentCount} >= ${Int[${limitParam}]}) {
            /if (${showDebug}) /echo [ProcessLootItem] SKIPPING - currentCount (${currentCount}) >= limit (${Int[${limitParam}]})
            /if (${showDebug} && (${thisName.Find[Spell]} || ${thisName.Find[Skill]})) /echo [DEBUG] WARNING: Wildcard item ${thisName} skipped due to limit - this shouldn't happen for wildcard items!
            /call AnnounceSkipped "${Target.ID}:${lootSlot}:${thisName}" "${tlTag} \ar*** LIMIT REACHED ***\aw You have reached your limit of ${Int[${limitParam}]} for ${Corpse.Item[${lootSlot}].ItemLink[CLICKABLE]} - skipping"
            /return
        }
        
        /call CheckInventorySpace "${thisName}" ${lootSlot}
        /call LootTheItem ${lootSlot} "${thisName}" ${Int[${limitParam}]} "${limitParam}"
    }
/return

| ---------------------------------------------------------------------
| LOOT HIGH VALUE ITEM
| ---------------------------------------------------------------------
Sub LootHighValueItem(int lootSlot)
    /declare tries int local 0
    /declare thisName string local
    
    /if (!${Corpse.Item[${lootSlot}].ID}) /return
    /varset thisName ${Corpse.Item[${lootSlot}].Name}
    /if (!${thisName.Length} || ${thisName.Equal[NULL]} || ${thisName.Equal[null]}) {
        /if (${showDebug}) /echo [turboLoot] ERROR: Cannot get item name for slot ${lootSlot} in LootHighValueItem
        /return
    }
    /varset LoreAttemptName "${thisName}"
    
    /if (${showDebug} || ${announceLooted}) /call Announce "${announceMethod}" "${tlTag} \ag[VALUE] ${Corpse.Item[${lootSlot}].ItemLink[CLICKABLE]} \at(worth ${Math.Calc[${Corpse.Item[${lootSlot}].Value} / 1000]}pp)"

:retryHigh
    /varcalc tries ${tries}+1

    | Clear cursor before looting (only if needed)
    /if (${Cursor.ID}) /call ForceClearCursor

    | Try to loot (shift-click auto-loots directly to inventory - faster)
    /shiftkey /itemnotify loot${lootSlot} leftmouseup
    | Shift-click usually auto-loots instantly - check immediately first (optimization)
    /doevents
    /if (!${Corpse.Item[${lootSlot}].ID}) {
        | Item already gone (shift-click auto-looted) - success!
        /varcalc itemsLooted ${itemsLooted}+1
        /return
    }
    | Item still on corpse - wait for shift-click to process OR lore denial message
    | Increased delay from 1 to 5 ticks to ensure LORE denial messages have time to arrive
    /delay 5 ${Cursor.ID} || !${Corpse.Item[${lootSlot}].ID} || ${LoreBlocked}
    /doevents

    | Handle quantity window inline (faster than subroutine call when window isn't open)
        /if (${Window[QuantityWnd].Open}) /call HandleQuantityWindow
        | Handle no-drop confirmation dialog
        /if (${Window[ConfirmationDialogBox].Open}) /call HandleNoDropConfirmation
    
        | LORE BLOCKED? Handle it immediately - don't second-guess empty names
        /if (${LoreBlocked}) {
            | Only ignore if we have a SPECIFIC different item name
            /if (${LoreBlockedName.Length} && ${LoreBlockedName.NotEqual[""]} && ${LoreBlockedName.NotEqual[NULL]} && !${thisName.Equal[${LoreBlockedName}]}) {
                /if (${showDebug}) /echo [turboLoot] LORE blocked message was for "${LoreBlockedName}", not "${thisName}" - ignoring
                /varset LoreBlocked FALSE
                /varset LoreBlockedName ""
            } else {
                /call HandleLoreBlocked ${lootSlot} "${thisName}"
                /return
            }
        }

    | Success? (check item gone OR cursor has item)
    /if (!${Corpse.Item[${lootSlot}].ID} || ${Cursor.ID}) {
        /varcalc itemsLooted ${itemsLooted}+1

        | Inventory the looted item (only clear cursor if needed - shift-click usually auto-loots)
        /doevents
        /if (${Cursor.ID}) /call ForceClearCursor

        /return
    }

    | Retry?
    /if (${tries} < ${MaxLootRetries}) /goto :retryHigh

    | Giving up
    /call HandleGiveUpLoot ${lootSlot} "${thisName}" ${tries}
/return

| ---------------------------------------------------------------------
| LOOT THE ITEM (normal looting)
| ---------------------------------------------------------------------
| limitParam: avoids shadowing outer itemLimit (which is "" for unlisted items)
Sub LootTheItem(int lootSlot, string thisName, int maxCount, string limitParam)
    /declare tries int local 0
    | itemLimitUpper is already declared as outer, so just set it (don't redeclare)
    /varset itemLimitUpper ${limitParam.Upper}
    /varset itemLimitUpper ${itemLimitUpper.Replace[ ,]}
    /if (${itemLimitUpper.Equal[SKIP]}) /varset itemLimitUpper IGNORE

    | Count how many we already have
    /varset currentCount ${Math.Calc[${FindItemCount[=${thisName}]}+${FindItemBankCount[=${thisName}]}]}

    | Already at limit?
    /if (${currentCount} >= ${maxCount}) {
        | Check if item still exists in corpse before accessing ItemLink
        /if (${Corpse.Item[${lootSlot}].ID}) {
            /call AnnounceSkipped "${Target.ID}:${lootSlot}:${thisName}" "${tlTag} \ar*** LIMIT REACHED ***\aw You have reached your limit of ${maxCount} for ${Corpse.Item[${lootSlot}].ItemLink[CLICKABLE]} - skipping"
        } else {
            /call AnnounceSkipped "${Target.ID}:${lootSlot}:${thisName}" "${tlTag} \ar*** LIMIT REACHED ***\aw You have reached your limit of ${maxCount} for ${thisName} - skipping"
        }
        /return
    }

    /varset LoreAttemptName "${thisName}"
    
    | Announce based on item limit type (SELL/BANK/TRIBUTE/WILD get special formatting with colors)
    /if (${showDebug} || ${announceLooted}) {
        /if (${itemLimitUpper.Equal[SELL]}) {
            /call Announce "${announceMethod}" "${tlTag} \ag[SELL] ${Corpse.Item[${lootSlot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID})"
        } else /if (${itemLimitUpper.Equal[BANK]}) {
            /call Announce "${announceMethod}" "${tlTag} \ap[BANK] ${Corpse.Item[${lootSlot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID})"
        } else /if (${itemLimitUpper.Equal[TRIBUTE]}) {
            /call Announce "${announceMethod}" "${tlTag} \ay[TRIBUTE] ${Corpse.Item[${lootSlot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID})"
        } else /if (${itemLimitUpper.Equal[WILD]}) {
            /call Announce "${announceMethod}" "${tlTag} \at[WILD] ${Corpse.Item[${lootSlot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID})"
        } else {
            /call Announce "${announceMethod}" "${tlTag} \ag[LOOT] ${Corpse.Item[${lootSlot}].ItemLink[CLICKABLE]}"
        }
    }

:retryLoot
    /varcalc tries ${tries}+1

    | Clear cursor before looting (only if needed)
    /if (${Cursor.ID}) /call ForceClearCursor

    | Try to loot (shift-click auto-loots directly to inventory - faster)
    /shiftkey /itemnotify loot${lootSlot} leftmouseup
    | Shift-click usually auto-loots instantly - check immediately first (optimization)
    /doevents
    /if (!${Corpse.Item[${lootSlot}].ID}) {
        | Item already gone (shift-click auto-looted) - success!
        /varcalc itemsLooted ${itemsLooted}+1
        /return
    }
    | Item still on corpse - wait for shift-click to process OR lore denial message
    | Increased delay from 1 to 5 ticks to ensure LORE denial messages have time to arrive
    /delay 5 ${Cursor.ID} || !${Corpse.Item[${lootSlot}].ID} || ${LoreBlocked}
    /doevents

    | Handle quantity window inline (faster than subroutine call when window isn't open)
    /if (${Window[QuantityWnd].Open}) /call HandleQuantityWindow

    | Handle no-drop confirmation dialog
    /if (${Window[ConfirmationDialogBox].Open}) /call HandleNoDropConfirmation

    | LORE BLOCKED? Handle it immediately - don't second-guess empty names
    /if (${LoreBlocked}) {
        | Only ignore if we have a SPECIFIC different item name
        /if (${LoreBlockedName.Length} && ${LoreBlockedName.NotEqual[""]} && ${LoreBlockedName.NotEqual[NULL]} && !${thisName.Equal[${LoreBlockedName}]}) {
            /if (${showDebug}) /echo [turboLoot] LORE blocked message was for "${LoreBlockedName}", not "${thisName}" - ignoring
            /varset LoreBlocked FALSE
            /varset LoreBlockedName ""
        } else {
            /call HandleLoreBlocked ${lootSlot} "${thisName}"
            /return
        }
    }

    | If item is gone, success
    /if (!${Corpse.Item[${lootSlot}].ID} || ${Cursor.ID}) {
        /varcalc itemsLooted ${itemsLooted}+1

        | Inventory the looted item (only clear cursor if needed)
        /doevents
        /if (${Cursor.ID}) /call ForceClearCursor

        | Alert when we just reached a numeric limit (obvious to user) - use Announce not AnnounceSkipped (we looted, didn't skip)
        /if ((${maxCount} < 999999) && (${maxCount} > 0)) {
            /varset currentCount ${Math.Calc[${FindItemCount[=${thisName}]}+${FindItemBankCount[=${thisName}]}]}
            /if (${currentCount} >= ${maxCount}) {
                /call Announce "${announceSkippedMethod}" "${tlTag} \ar*** LIMIT REACHED ***\aw You now have ${currentCount}/${maxCount} ${thisName}"
            }
        }

        /return
    }

    | Retry?
    /if (${tries} < ${MaxLootRetries}) /goto :retryLoot

    | Giving up
    /call HandleGiveUpLoot ${lootSlot} "${thisName}" ${tries}
/return

| ---------------------------------------------------------------------
| LOOT AND DESTROY CORPSE ITEM
| ---------------------------------------------------------------------
Sub LootAndDestroyCorpseItem(int lootSlot, string destroyName)
    /declare tries int local 0

:LootDestroyLoop
    /if (!${Corpse.Item[${lootSlot}].ID}) /return

    /varcalc tries ${tries}+1
    /if (${tries} >= ${MaxLootRetries}) {
        /if (${showDebug} || ${announceSkipped}) {
            /declare msg string local ${FormatMessage[${tlTag} \ar[DESTROY] ${destroyName} \at(ID: ${Target.ID}) - failed ${tries}x,${announceMethod}]}
            /docommand /${announceMethod} ${msg}
        }
        | Don't mark entire corpse as skip - just this item failed
        | /alert add ${AlertIndex} id ${Target.ID}
        | /varset Skip TRUE
        /return
    }

    | Try to loot (shift-click auto-loots directly to inventory - faster)
    /shiftkey /itemnotify loot${lootSlot} leftmouseup
    | Wait briefly for item on cursor (shift-click usually puts it there instantly)
    /delay 1 ${Cursor.ID}

    | Handle no-drop confirmation dialog
    /if (${Window[ConfirmationDialogBox].Open}) /call HandleNoDropConfirmation

    /if (${Cursor.ID}) {
        /destroy
        | Conditional delay - exits early when cursor is empty
        /delay 10 !${Cursor.ID}
        /varcalc itemsDestroyed ${itemsDestroyed}+1
        /return
    }

    | If item is gone from corpse, done
    /if (!${Corpse.Item[${lootSlot}].ID}) /return

    | Retry?
    /if (${tries} < ${MaxLootRetries}) /goto :LootDestroyLoop

    | Giving up
    /call HandleGiveUpLoot ${lootSlot} "${destroyName}" ${tries}
/return

| ---------------------------------------------------------------------
| HELPER FUNCTIONS
| ---------------------------------------------------------------------
| WILDCARD DETECTION (checks against prefixes loaded from [Wildcards] INI section)
| ---------------------------------------------------------------------
Sub IsWildcardItem(string name)
    | Checks item name against all prefixes loaded from [Wildcards] INI section.
    | wildcardPrefixes format: |6:SPELL:||5:SONG:||8:TOME OF |
    /if (!${wildcardPrefixes.Length}) /return FALSE

    /declare u string local ${name.Upper}
    /declare searchPos int local 1
    /declare pipeEnd int local
    /declare entry string local
    /declare colonPos int local
    /declare prefixLen int local
    /declare prefix string local
    /declare chunk string local

    | Walk through each |LEN:PREFIX| entry
    :nextWildcard
    | Find the start of next entry (skip the leading pipe)
    /varset searchPos ${Math.Calc[${searchPos}+1]}
    /if (${searchPos} >= ${wildcardPrefixes.Length}) /return FALSE

    | Get remaining string from current position
    /varset chunk ${wildcardPrefixes.Mid[${searchPos},500]}
    /if (!${chunk.Length}) /return FALSE

    | Find the closing pipe
    /varset pipeEnd ${chunk.Find[|]}
    /if (!${pipeEnd} || ${pipeEnd} < 3) /return FALSE

    /varset entry ${chunk.Left[${Math.Calc[${pipeEnd}-1]}]}
    /varset searchPos ${Math.Calc[${searchPos}+${pipeEnd}-1]}

    | Parse LEN:PREFIX
    /varset colonPos ${entry.Find[:]}
    /if (!${colonPos}) /goto :nextWildcard

    /varset prefixLen ${Int[${entry.Left[${Math.Calc[${colonPos}-1]}]}]}
    /if (${prefixLen} < 1 || ${prefixLen} > ${u.Length}) /goto :nextWildcard

    /varset prefix ${entry.Mid[${Math.Calc[${colonPos}+1]},${prefixLen}]}
    /if (${u.Left[${prefixLen}].Equal[${prefix}]}) /return TRUE

    /goto :nextWildcard
/return FALSE

| ---------------------------------------------------------------------
| HANDLE QUANTITY WINDOW
| ---------------------------------------------------------------------
Sub HandleQuantityWindow
    /if (!${Window[QuantityWnd].Open}) /return

    /if (${showDebug}) /echo [turboLoot] QuantityWnd detected - attempting to accept

    | Accept quantity window (conditional delay - exits early when window closes)
    /squelch /notify QuantityWnd AcceptButton leftmouseup
    /squelch /notify QuantityWnd QTYW_Accept_Button leftmouseup
    /keypress ENTER
    /delay 3 !${Window[QuantityWnd].Open}
    | Wait for item to reach inventory (prevents "cursor occupied" on next loot)
    /if (${Cursor.ID}) {
        /delay 5 !${Cursor.ID}
        /if (${Cursor.ID}) /call ForceClearCursor
    }

    /if (${Window[QuantityWnd].Open}) {
        /echo [turboLoot] ERROR: Quantity window stuck open. Aborting macro.
        /if (${Me.Grouped}) /docommand /${announceMethod} [turboLoot] ERROR: Quantity window stuck open. Aborting looting.
        /varset abortingMacro TRUE
        /call Cleanup
        /endmac
    }
/return

| ---------------------------------------------------------------------
| HANDLE NO-DROP CONFIRMATION
| ---------------------------------------------------------------------
Sub HandleNoDropConfirmation
    /if (!${Window[ConfirmationDialogBox].Open}) /return
    
    /if (${showDebug}) /echo [turboLoot] No-drop confirmation dialog detected
    
    | Click Yes to accept the no-drop item
    /notify ConfirmationDialogBox Yes_Button leftmouseup
    /delay 5 !${Window[ConfirmationDialogBox].Open}
    
    | If still open, try alternate button name
    /if (${Window[ConfirmationDialogBox].Open}) {
        /notify ConfirmationDialogBox CD_Yes_Button leftmouseup
        /delay 5 !${Window[ConfirmationDialogBox].Open}
    }
    
    | Last resort - press Enter key
    /if (${Window[ConfirmationDialogBox].Open}) {
        /keypress ENTER
        /delay 3 !${Window[ConfirmationDialogBox].Open}
    }
/return

| ---------------------------------------------------------------------
| CHECK INVENTORY SPACE
| ---------------------------------------------------------------------
Sub CheckInventorySpace(string itemName, int lootSlot)
    /declare quantity int local ${Corpse.Item[${lootSlot}].Stack}
    /declare stackSize int local ${Corpse.Item[${lootSlot}].StackSize}
    /varset currentCount ${FindItemCount[=${itemName}]}

    | Use FindItem[].Stacks to get number of full stacks we currently have
    /declare currentStacks int local 0
    /if (${FindItem[=${itemName}].ID}) {
        /varset currentStacks ${FindItem[=${itemName}].Stacks}
    }
    /declare totalInFullStacks int local ${Math.Calc[${currentStacks} * ${stackSize}]}

    | Space available to top off existing stacks
    /declare spaceInCurrentStacks int local ${Math.Calc[${totalInFullStacks} - ${currentCount}]}
    /if (${spaceInCurrentStacks} < 0) /varset spaceInCurrentStacks 0

    | If the corpse quantity fits into existing partial stack space, no new stacks are needed
    /if (${quantity} <= ${spaceInCurrentStacks}) /return

    | Otherwise compute how many additional stacks are required
    /declare extraNeeded int local ${Math.Calc[${quantity} - ${spaceInCurrentStacks}]}
    /if (${stackSize} <= 1) {
        /declare newStacksNeeded int local ${extraNeeded}
    } else {
        /declare newStacksNeeded int local ${Math.Calc[(${extraNeeded} + ${stackSize} - 1) / ${stackSize}]}
    }

    /if (${newStacksNeeded} <= 0) /return

    /declare free int local ${Me.FreeInventory}

    /if (${free} > ${Math.Calc[2 * ${announceInventoryAlmostFull}]} && ${free} <= ${Math.Calc[3 * ${announceInventoryAlmostFull}]}) {
        /call Announce "${announceMethod}" "\ay[INVENTORY] ${free} slots free (threshold: ${announceInventoryAlmostFull})"
    }
 
    /if (${free} > ${announceInventoryAlmostFull} && ${free} <= ${Math.Calc[2 * ${announceInventoryAlmostFull}]}) {
        /call Announce "${announceMethod}" "\ao[INVENTORY] ${free} slots free (threshold: ${announceInventoryAlmostFull})"
    }

    /if (${free} <= ${announceInventoryAlmostFull}) {
        /call Announce "${announceMethod}" "\ar[INVENTORY] ${free} slots free (threshold: ${announceInventoryAlmostFull})"
    }
/return

| ---------------------------------------------------------------------
| HANDLE LORE BLOCKED
| ---------------------------------------------------------------------
Sub HandleLoreBlocked(int lootSlot, string thisName)
    | Get item link if available, otherwise use the name we were passed
    /declare itemDisplay string local ${Corpse.Item[${lootSlot}].ItemLink[CLICKABLE]}
    /if (!${itemDisplay.Length} || ${itemDisplay.Equal[NULL]}) {
        /varset itemDisplay ${thisName}
    }
    
    | Use AnnounceSkipped so all skip announcements honor announceSkipTo (announceSkippedMethod)
    /call AnnounceSkipped "${Target.ID}:${lootSlot}:${thisName}" "\ao[SKIP] ${itemDisplay} \at(ID: ${Target.ID}) \at(already owned)"

    | DON'T mark corpse as alerted - we want to continue looting other items on this corpse
    | The item name is added to LoreDeniedNames cache so we won't retry THIS item
    /if (${LoreDeniedNames.Length} > 2000) /varset LoreDeniedNames ""
    /if (${LoreAttemptName.Length} && (!${LoreDeniedNames.Length} || !${LoreDeniedNames.Find[|${LoreAttemptName}|]})) {
        /varset LoreDeniedNames "${LoreDeniedNames}|${LoreAttemptName}|"
    }

    | Reset lore flags
    /varset LoreBlocked FALSE
    /varset LoreBlockedName ""
/return

| ---------------------------------------------------------------------
| HANDLE GIVE UP (max retries)
| ---------------------------------------------------------------------
Sub HandleGiveUpLoot(int lootSlot, string thisName, int tries)
    | If this is a LORE item and we failed to loot it, treat as lore-blocked
    | This handles cases where the server's lore denial message doesn't match our event patterns
    /if (${Corpse.Item[${lootSlot}].Lore}) {
        /if (${showDebug}) /echo [turboLoot] LORE item failed after ${tries} attempts - treating as lore-blocked
        | Add to lore denied cache so we don't retry on other corpses
        /if (${LoreDeniedNames.Length} > 2000) /varset LoreDeniedNames ""
        /if (!${LoreDeniedNames.Length} || !${LoreDeniedNames.Find[|${thisName}|]}) /varset LoreDeniedNames "${LoreDeniedNames}|${thisName}|"
        | Announce as skip
        /call AnnounceSkipped "${Target.ID}:${lootSlot}:${thisName}" "${tlTag} \ao[SKIP] ${Corpse.Item[${lootSlot}].ItemLink[CLICKABLE]} \at(ID: ${Target.ID}) \at(lore - already owned)"
        /return
    }

    | Count as skipped and announce (failed to loot after retries)
    /call AnnounceSkipped "${Target.ID}:${lootSlot}:${thisName}" "${tlTag} \ar[GIVING UP] ${Corpse.Item[${lootSlot}].ItemLink[CLICKABLE]} \at(failed ${tries}x)"

    | Don't mark entire corpse as skip - just this item failed
    | The /for loop will continue to the next item automatically
/return

| ---------------------------------------------------------------------
| UTILITY FUNCTIONS
| ---------------------------------------------------------------------
Sub CloseBags
    /declare bag int local

    /if (${Window[InventoryWindow].Open}) /nomodkey /notify InventoryWindow DoneButton leftmouseup
    /for bag 1 to 10
        /if (${Window[pack${bag}].Open}) /nomodkey /itemnotify pack${bag} rightmouseup
    /next bag
/return

Sub Event_Unlootable
    /varset Skip TRUE
    /alert add ${AlertIndex} id ${Target.ID}
    /if (${showDebug}) /echo [turboLoot] CANNOT LOOT ID: ${Target.ID} (marking corpse to skip)
/return


Sub Event_TooFar
    /varset Skip TRUE
    /alert add ${AlertIndex} id ${Target.ID}
    /if (${showDebug}) /echo [turboLoot] ID: ${Target.ID} is too far (marking corpse to skip)
/return

Sub Event_CursorOccupied
    /if (${showDebug}) /echo [turboLoot] Cursor occupied - clearing cursor
    /call ForceClearCursor
    /delay 2 !${Cursor.ID}
    /if (${Cursor.ID}) /call ForceClearCursor
/return


Sub Event_LoreAlreadyPossess(string itemName)
    /varset LoreBlocked TRUE
    /varset LoreBlockedName "${itemName}"
    /if (${LoreDeniedNames.Length} > 2000) /varset LoreDeniedNames ""
    /if (!${LoreDeniedNames.Length} || !${LoreDeniedNames.Find[|${itemName}|]}) /varset LoreDeniedNames "${LoreDeniedNames}|${itemName}|"
    /if (${showDebug}) /echo [turboLoot] LORE blocked (already possess): "${itemName}" - ID: ${Target.ID}
/return


Sub Event_LoreAlreadyHaveOne
    /varset LoreBlocked TRUE
    /varset LoreBlockedName ""
    /if (${LoreDeniedNames.Length} > 2000) /varset LoreDeniedNames ""
    /if (${LoreAttemptName.Length} && (!${LoreDeniedNames.Length} || !${LoreDeniedNames.Find[|${LoreAttemptName}|]})) /varset LoreDeniedNames "${LoreDeniedNames}|${LoreAttemptName}|"
    /if (${showDebug}) /echo [turboLoot] LORE blocked (already have one) - ID: ${Target.ID}
/return


Sub Event_LoreAlreadyHaveOneExact
    /varset LoreBlocked TRUE
    /varset LoreBlockedName ""
    /if (${LoreDeniedNames.Length} > 2000) /varset LoreDeniedNames ""
    /if (${LoreAttemptName.Length} && (!${LoreDeniedNames.Length} || !${LoreDeniedNames.Find[|${LoreAttemptName}|]})) /varset LoreDeniedNames "${LoreDeniedNames}|${LoreAttemptName}|"
    /if (${showDebug}) /echo [turboLoot] LORE blocked (already have one) [exact] - ID: ${Target.ID}
/return


Sub Event_LoreDeniedGeneric
    /varset LoreBlocked TRUE
    /varset LoreBlockedName ""
    /if (${LoreDeniedNames.Length} > 2000) /varset LoreDeniedNames ""
    /if (${LoreAttemptName.Length} && (!${LoreDeniedNames.Length} || !${LoreDeniedNames.Find[|${LoreAttemptName}|]})) /varset LoreDeniedNames "${LoreDeniedNames}|${LoreAttemptName}|"
    /if (${showDebug}) /echo [turboLoot] LORE blocked (generic) - ID: ${Target.ID}
/return


Sub Event_LoreAlreadyPossessNoName
    /varset LoreBlocked TRUE
    /varset LoreBlockedName ""
    /if (${LoreDeniedNames.Length} > 2000) /varset LoreDeniedNames ""
    /if (${LoreAttemptName.Length} && (!${LoreDeniedNames.Length} || !${LoreDeniedNames.Find[|${LoreAttemptName}|]})) /varset LoreDeniedNames "${LoreDeniedNames}|${LoreAttemptName}|"
    /if (${showDebug}) /echo [turboLoot] LORE blocked (already possess) - ID: ${Target.ID}
/return



| ---------------------------------------------------------------------
| CLEANUP (end-of-run cleanup)
| ---------------------------------------------------------------------
Sub Cleanup
    /if (${showDebug}) /echo [turboLoot] Cleanup: Starting cleanup routine
    /if (${Window[QuantityWnd].Open} && !${abortingMacro}) {
        /squelch /notify QuantityWnd AcceptButton leftmouseup
        /squelch /notify QuantityWnd QTYW_Accept_Button leftmouseup
        /keypress ENTER
        /delay 1
    }
    /call ClearCursor
    /varset modeCheck ${restoreFollowMode.Upper.Replace[ ,]}
    /if (${modeCheck.NotEqual[NONE]} && ${modeCheck.Length} && ${modeCheck.NotEqual[NULL]} && ${modeCheck.NotEqual[0]}) {
        /call StopFollowAndMovement
    }
    /call TryCloseLootWindow
    /e3p off
    /delay 10
    /call UnpauseAFollow
    /docommand /lootnodrop ${lootNoDropPromptReset}
/return


Sub StopFollowAndMovement
    /squelch /stick off
    /call PauseAFollow
    /squelch /moveto off
    /squelch /nav stop
    /squelch /keypress forward
    /delay 1
/return




|| ---------------------------------------------------------------------
|| PAUSE/UNPAUSE AFOLLOW
|| ---------------------------------------------------------------------
Sub PauseAFollow
    | Check if MQ2AdvPath plugin is loaded before checking Following state
    /if (${Plugin[MQ2AdvPath].Name.Length}) {
        /if (${AdvPath.Following}) {
            /if (${showDebug}) /echo [turboLoot] PauseAFollow: Pausing /afollow (was active)
            /varset afollowWasPaused TRUE
        } else {
            /if (${showDebug}) /echo [turboLoot] PauseAFollow: /afollow was not active, not tracking
            /varset afollowWasPaused FALSE
        }
    } else {
        | Plugin not loaded - assume /afollow might be active and track it
        /if (${showDebug}) /echo [turboLoot] PauseAFollow: MQ2AdvPath not loaded, assuming /afollow might be active
        /varset afollowWasPaused TRUE
    }
    /squelch /afollow off
    /delay 1
/return


Sub UnpauseAFollow
    | Check if currently feigning death - don't restore follow while FD
    /if (${Me.Feigning}) {
        /if (${showDebug}) /echo [turboLoot] UnpauseAFollow: Skipping (currently FD)
        /varset afollowWasPaused FALSE
        /return
    }
    
    /if (${afollowWasPaused}) {
        /if (${showDebug}) /echo [turboLoot] UnpauseAFollow: Restoring /afollow (was paused by macro)
        /if (${Me.Grouped} && ${Group.Leader.ID} && !${Target.ID}) {
            /target id ${Group.Leader.ID}
            /delay 2
        }
        /squelch /afollow on
        /varset afollowWasPaused FALSE
        /delay 1
    } else {
        /if (${showDebug}) /echo [turboLoot] UnpauseAFollow: Skipping (afollow was not active when macro started)
    }
/return


Sub ClearCursor
    /if (!${Cursor.ID}) /return
    /if (${showDebug}) /echo [turboLoot] Cursor item detected during cleanup: ${Cursor.Name} (attempting /autoinventory)

    | Try to clear cursor (optimized with conditional delays like ForceClearCursor)
    /autoinventory
    /delay 10 !${Cursor.ID}
    /if (${Cursor.ID}) {
        /autoi
        /delay 10 !${Cursor.ID}
        /if (${Cursor.ID}) {
            /autoinventory
            /delay 10 !${Cursor.ID}
        }
    }

    /if (${Cursor.ID}) /echo [turboLoot] WARNING: Item still on cursor after cleanup: ${Cursor.Name}. You may need to manually clear it.
/return

Sub ForceClearCursor
    /if (${Cursor.ID}) {
        /if (${showDebug}) /echo [turboLoot] Cursor has item: ${Cursor.Name} - clearing
        /autoinventory
        /delay 3 !${Cursor.ID}
        /if (${Cursor.ID}) {
            /autoi
            /delay 3 !${Cursor.ID}
        }
    }
/return


Sub TryCloseLootWindow
    /if (!${Window[LootWnd].Open}) /return
    /squelch /notify LootWnd DoneButton leftmouseup
    /delay 1
    /if (${Window[LootWnd].Open}) {
        /keypress ESC
        /delay 1
    }
    /if (${Window[LootWnd].Open}) {
        /squelch /notify LootWnd DoneButton leftmouseup
        /delay 1
    }
    /if (${Window[LootWnd].Open}) /squelch /windowstate LootWnd close
/return


Sub StripColorCodes(string msg)
    /declare result string local ${msg}
    /varset result ${result.Replace[\at,]}
    /varset result ${result.Replace[\ao,]}
    /varset result ${result.Replace[\ag,]}
    /varset result ${result.Replace[\ar,]}
    /varset result ${result.Replace[\am,]}
    /varset result ${result.Replace[\au,]}
    /varset result ${result.Replace[\aw,]}
    /varset result ${result.Replace[\ax,]}
    /varset result ${result.Replace[\ay,]}
    /varset result ${result.Replace[\ap,]}
/return ${result}

Sub FormatMessage(string msg, string method)
    /declare methodUpper string local ${method.Upper}
    /declare result string local ${msg}
    /if (${methodUpper.Equal[ECHO]} || ${methodUpper.Equal[E3BC]}) {
        /return ${result}
    }
    /varset result ${StripColorCodes[${result}]}
    /varset result ${result.Replace[[turboLoot] ,]}
    /varset result ${result.Replace[[turboLoot],]}
/return ${result}

Sub StripIniComment(string v)
    /declare result string local ${v}
    /if (${result.Find[;]}) /varset result ${result.Left[${Math.Calc[${result.Find[;]}-1]}]}
/return ${result}

Sub TrimSpaces(string v)
    /declare result string local ${v}
:trimLeft
    /if (${result.Length} && (${result.Left[1].Equal[" "]} || ${result.Left[1].Equal["	"]})) {
        /varset result ${result.Right[-1]}
        /goto :trimLeft
    }
:trimRight
    /if (${result.Length} && (${result.Right[1].Equal[" "]} || ${result.Right[1].Equal["	"]})) {
        /varset result ${result.Left[${Math.Calc[${result.Length}-1]}]}
        /goto :trimRight
    }
:trimQuotesLeft
    /if (${result.Length} && ${result.Left[1].Equal["\""]}) {
        /varset result ${result.Right[-1]}
        /goto :trimQuotesLeft
    }
:trimQuotesRight
    /if (${result.Length} && ${result.Right[1].Equal["\""]}) {
        /varset result ${result.Left[${Math.Calc[${result.Length}-1]}]}
        /goto :trimQuotesRight
    }
/return ${result}

Sub NormalizeAnnounceMethod(string v)
    | Normalizes announce method strings:
    | - trims whitespace + surrounding quotes
    | - strips a leading '/'
    | - maps common variants to canonical commands (prefix-match to tolerate hidden trailing chars)
    /declare result string local ${TrimSpaces[${v}]}
    /if (${result.Length} && ${result.Left[1].Equal[/]}) /varset result ${result.Right[-1]}
    /declare upper string local ${result.Upper}
    /if (${upper.Left[4].Equal[E3BC]}) /return e3bc
    /if (${upper.Left[4].Equal[ECHO]}) /return echo
    /if (${upper.Left[3].Equal[SAY]}) /return say
    /if ((${upper.Length} == 1 && ${upper.Equal[G]}) || ${upper.Left[4].Equal[GSAY]}) /return gsay
    /if ((${upper.Length} == 2 && ${upper.Equal[RS]}) || ${upper.Left[4].Equal[RSAY]}) /return rsay
    /return ${result}

Sub IniGetStringOrEmpty(string section, string key)
    /declare raw string local ${Ini[${iniFile},${section},${key}]}
    /if (!${raw.Length} || ${raw.Equal[NULL]} || ${raw.Equal[Null]} || ${raw.Equal[null]}) /return ""
    /declare cleaned string local ${StripIniComment[${raw}]}
    /declare trimmed string local ${TrimSpaces[${cleaned}]}
/return ${trimmed}

Sub AnnounceBankSell(string msg)
    | Announce banking/selling messages with color stripping for non-echo/e3bc methods
    | Ensure announceBankSell is set (fallback to echo if not initialized)
    /if (!${Defined[announceBankSell]} || !${announceBankSell.Length} || ${announceBankSell.Equal[NULL]} || ${announceBankSell.Equal[null]}) {
        /varset announceBankSell "echo"
    }
    /declare bankSellMethod string local ${NormalizeAnnounceMethod[${announceBankSell}]}
    /if (!${bankSellMethod.Length}) /varset bankSellMethod "echo"
    /declare bankSellUpper string local ${bankSellMethod.Upper.Replace[ ,]}
    /if (${bankSellUpper.Equal[0]} || ${bankSellUpper.Equal[OFF]}) /return
    /if (${bankSellMethod.Upper.Equal[ECHO]} || ${bankSellMethod.Upper.Equal[E3BC]}) {
        | /squelch hides the "command received:/e3bc ..." spam while still outputting the message.
        /docommand /squelch /${bankSellMethod} ${msg}
    } else {
        /declare formattedMsg string local ${FormatMessage[${msg},${bankSellMethod}]}
        /docommand /${bankSellMethod} ${formattedMsg}
    }
/return

Sub AnnounceBankSellProgress(string msg)
    | Progress/status chatter for BANK/SELL/TRIBUTE (optional via INI)
    /if (${announceBankSellProgress} != 0) {
        /call AnnounceBankSell "${msg}"
    } else /if (${showDebug}) {
        /echo [turboLoot] DBG(progress) ${msg}
    }
/return

Sub AnnounceBankSellPerItem(string msg)
    /call AnnounceBankSell "${msg}"
/return

Sub AnnounceSkipped(string key, string msg)
    /varcalc itemsSkipped ${itemsSkipped}+1
    /echo ${msg}
    /declare itemNameFromKey string local
    /if (${key.Find[:]}) {
        /varset itemNameFromKey ${key.Right[-${key.Find[:]}]}
        /if (${itemNameFromKey.Find[:]}) {
            /varset itemNameFromKey ${itemNameFromKey.Right[-${itemNameFromKey.Find[:]}]}
        }
    }
    /declare hasItemLink bool local FALSE
    /if (${msg.Find[ItemLink]} || ${msg.Find[\ax]} || ${msg.Length} > 200) {
        /varset hasItemLink TRUE
    }
    /if (!${hasItemLink}) {
        /varset msg ${msg.Replace[NULL,${itemNameFromKey}]}
        /varset msg ${msg.Replace[null,${itemNameFromKey}]}
    }
    /declare skipMethodUpper string local ${announceSkippedMethod.Upper}
    /declare effectiveMethod string local ${announceSkippedMethod}
    /if (!${effectiveMethod.Length}) /varset effectiveMethod echo
    /if ((${skipMethodUpper.Equal[GSAY]} || ${skipMethodUpper.Equal[G]}) && !${Me.Grouped}) {
        /varset effectiveMethod echo
    }
    /if ((${skipMethodUpper.Equal[GSAY]} || ${skipMethodUpper.Equal[G]}) && ${Me.Grouped}) {
        /declare groupMsg string local ${msg}
        /varset groupMsg ${groupMsg.Replace[\at,]}
        /varset groupMsg ${groupMsg.Replace[\ao,]}
        /varset groupMsg ${groupMsg.Replace[\ag,]}
        /varset groupMsg ${groupMsg.Replace[\ar,]}
        /varset groupMsg ${groupMsg.Replace[\am,]}
        /varset groupMsg ${groupMsg.Replace[\au,]}
        /varset groupMsg ${groupMsg.Replace[\aw,]}
        /varset groupMsg ${groupMsg.Replace[\ay,]}
        /varset groupMsg ${groupMsg.Replace[\ap,]}
        /varset groupMsg ${groupMsg.Replace[[turboLoot] ,]}
        /varset groupMsg ${groupMsg.Replace[[turboLoot],]}
        /call GsayOnce "${key}" "${groupMsg}"
    } else {
        /declare formattedMsg string local ${FormatMessage[${msg},${effectiveMethod}]}
        /docommand /${effectiveMethod} ${formattedMsg}
    }
/return

Sub GsayOnce(string key, string msg)
    /if (!${Me.Grouped}) /return
    /if (${SkipGsayKeys.Length} > 2000) /varset SkipGsayKeys ""
    /if (${SkipGsayKeys.Length} && ${SkipGsayKeys.Find[|${key}|]}) /return
    /varset SkipGsayKeys "${SkipGsayKeys}|${key}|"
    /gsay ${msg}
/return


| ---------------------------------------------------------------------
| PRINT SUMMARY (telemetry)
| ---------------------------------------------------------------------
Sub PrintSummary
    | Only print summary if enabled in INI
    /if (${announceSummary} == 0) /return
    
    /call Announce "${announceSummaryMethod}" "${tlTag} \agLooted: ${itemsLooted}"
    /call Announce "${announceSummaryMethod}" "${tlTag} \arDestroyed: ${itemsDestroyed}"
    /call Announce "${announceSummaryMethod}" "${tlTag} \awSkipped: ${itemsSkipped} Ignored: ${itemsIgnored}"
    /call Announce "${announceSummaryMethod}" "${tlTag} \aoDuration: ${Macro.RunTime}s"
/return

| ---------------------------------------------------------------------
| PRINT UNLOAD SUMMARY (BANK -> TRIBUTE -> SELL)
| ---------------------------------------------------------------------
Sub PrintUnloadSummary
    /declare soldPP int local ${Int[${Math.Calc[${sellTotalCopper}/1000]}]}
    /declare soldGP int local ${Int[${Math.Calc[(${sellTotalCopper}%1000)/100]}]}
    /declare soldSP int local ${Int[${Math.Calc[(${sellTotalCopper}%100)/10]}]}
    /declare soldCP int local ${Int[${Math.Calc[${sellTotalCopper}%10]}]}

    /call AnnounceBankSell "${tlTag} \au[\ao===== \amTURBOUNLOAD \ao=====\au]\ax"
    /call AnnounceBankSell "${tlTag} \ap[BANKED TOTAL]\aw --> \ag${itemsBanked}"
    /call AnnounceBankSell "${tlTag} \ay[TRIBUTED TOTAL]\aw --> \ag${tributeItemsMoved}\aw (\at+${tributePointsGained}\aw TP)"
    /call AnnounceBankSell "${tlTag} \ag[SOLD TOTAL]\aw --> \ag${itemsSold}\aw (\ag${soldPP}\awpp \ag${soldGP}\awgp \ag${soldSP}\awsp \ag${soldCP}\awcp)"
/return

||| ---------------------------------------------------------------------
||| DISPLAY DRY RUN SELL ITEM (mirrors SellItem output format)
||| ---------------------------------------------------------------------
Sub DisplayDryRunSellItem(int bagNum, int slotNum, string itemName, string classification)
    | Display function that mirrors SellItem's output format but doesn't actually sell
    | Gets ItemLink fresh, calculates value, formats exactly like SellItem does
    /declare sellItemLink string local
    /declare stackCount int local 1
    /declare perItemCopper int local 0
    /declare totalStackCopper int local 0
    /declare p int local 0
    /declare g int local 0
    /declare s int local 0
    /declare c int local 0
    
    | Get item data (same as SellItem lines 4005-4018)
    /if (${bagNum} == 0) {
        | Main inventory slot (23-32)
        /varset sellItemLink ${Me.Inventory[${slotNum}].ItemLink[CLICKABLE]}
        /if (${Me.Inventory[${slotNum}].Stackable}) /varset stackCount ${Me.Inventory[${slotNum}].Stack}
        /varset perItemCopper ${Me.Inventory[${slotNum}].Value}
    } else {
        | Bag slot
        /varset sellItemLink ${Me.Inventory[pack${bagNum}].Item[${slotNum}].ItemLink[CLICKABLE]}
        /if (${Me.Inventory[pack${bagNum}].Item[${slotNum}].Stackable}) /varset stackCount ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Stack}
        /varset perItemCopper ${Me.Inventory[pack${bagNum}].Item[${slotNum}].Value}
    }
    
    | Fallback to itemName if ItemLink failed
    /if (!${sellItemLink.Length} || ${sellItemLink.Equal[NULL]}) {
        /varset sellItemLink ${itemName}
    }
    
    | Skip items with 0 value (same as SellItem)
    /if (${perItemCopper} <= 0) /return
    
    | Calculate total value (same as SellItem lines 4043-4044)
    /varset totalStackCopper ${Math.Calc[${perItemCopper}*${stackCount}]}
    
    | Build currency text (same as SellItem lines 4141-4145)
    /varset p ${Int[${Math.Calc[${totalStackCopper}/1000]}]}
    /varset g ${Int[${Math.Calc[(${totalStackCopper}%1000)/100]}]}
    /varset s ${Int[${Math.Calc[(${totalStackCopper}%100)/10]}]}
    /varset c ${Int[${Math.Calc[${totalStackCopper}%10]}]}
    
    | Display (same format as SellItem line 4148, but with classification parameter)
    /call AnnounceBankSell "${tlTag} ${classification} ${sellItemLink} \aw(x${stackCount}) \awfor \ag${p}pp ${g}gp ${s}sp ${c}cp\ag"
    
    | Track totals
    /varcalc dryRunSellCount ${dryRunSellCount}+1
    /varcalc dryRunSellTotalCopper ${dryRunSellTotalCopper}+${totalStackCopper}
/return

||| ---------------------------------------------------------------------
||| PRINT DRY RUN SELL SUMMARY
||| ---------------------------------------------------------------------
Sub PrintDryRunSellSummary
    | Calculate total currency breakdown from total copper
    /declare soldPP int local ${Int[${Math.Calc[${dryRunSellTotalCopper}/1000]}]}
    /declare soldGP int local ${Int[${Math.Calc[(${dryRunSellTotalCopper}%1000)/100]}]}
    /declare soldSP int local ${Int[${Math.Calc[(${dryRunSellTotalCopper}%100)/10]}]}
    /declare soldCP int local ${Int[${Math.Calc[${dryRunSellTotalCopper}%10]}]}
    
    | Items are already displayed above, just show totals
    /if (${dryRunSellCount} > 0) {
        /call AnnounceBankSell "${tlTag} \agTotal: ${dryRunSellCount} items, \ag${soldPP}pp ${soldGP}gp ${soldSP}sp ${soldCP}cp"
    } else {
        /call AnnounceBankSell "${tlTag} \aoNo items would be sold."
        /call AnnounceBankSell "${tlTag} \awCheck your \ayturboLoot.ini \aw[ItemLimits] section."
    }
    
    /call AnnounceBankSell "${tlTag} \au======================================================="
    /call AnnounceBankSell "${tlTag} \aoDRY RUN COMPLETE - Run \ag/mac turboloot sell\ao (without 'dryrun') to execute"
    /call AnnounceBankSell "${tlTag} \au======================================================="
/return

| ---------------------------------------------------------------------
| PRINT COMMANDS / TOGGLES (help)
| ---------------------------------------------------------------------
Sub GetHelpAnnounceMethod
    | Default to echo if INI is missing or misconfigured
    /declare method string local "echo"
    /declare cfgIni string local "../Config/turboloot.ini"
    /declare macIni string local "../Macros/turboloot.ini"
    /declare chosenIni string local ""

    /if (${Ini.File[${cfgIni}].Exists}) {
        /varset chosenIni ${cfgIni}
    } else /if (${Ini.File[${macIni}].Exists}) {
        /varset chosenIni ${macIni}
    }

    /if (${chosenIni.Length}) {
        /declare raw string local ${Ini[${chosenIni},Settings,announceDefaultTo]}
        /if (${raw.Length} && !${raw.Equal[NULL]} && !${raw.Equal[Null]} && !${raw.Equal[null]}) {
            /declare cleaned string local ${TrimSpaces[${StripIniComment[${raw}]}]}
            /if (${cleaned.Length}) {
                /declare normalized string local ${NormalizeAnnounceMethod[${cleaned}]}
                /if (${normalized.Length}) /varset method ${normalized}
            }
        }
    }

    /declare methodUpper string local ${method.Upper.Replace[ ,]}
    /if (${methodUpper.Equal[0]} || ${methodUpper.Equal[OFF]}) /varset method "echo"
/return ${method}

Sub HelpAnnounce(string method, string msg)
    /declare m string local ${NormalizeAnnounceMethod[${method}]}
    /if (!${m.Length}) /varset m "echo"
    /declare mUpper string local ${m.Upper}

    /if (${mUpper.Equal[ECHO]} || ${mUpper.Equal[E3BC]}) {
        | Keep colors in MQ window / E3BC, and squelch command spam
        /docommand /squelch /${m} ${msg}
    } else {
        | Strip MQ color codes for chat channels
        /declare plain string local ${StripColorCodes[${msg}]}
        /docommand /${m} ${plain}
    }
/return

Sub PrintCommandsAndToggles
    /declare helpMethod string local "echo"
    /declare helpTag string local "\at[turboLoot]\ax"
    /call GetHelpAnnounceMethod
    /if (${Macro.Return.Length}) /varset helpMethod ${Macro.Return}
    /if (!${helpMethod.Length}) /varset helpMethod "echo"

    /call HelpAnnounce "${helpMethod}" "${helpTag} \au==== \agCOMMANDS \au====\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag} \ag/mac turboloot\ax \aw(loot mode)\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag} \ag/mac turboloot sell\ax \aw(sell items marked \agSELL\aw)\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag} \ag/mac turboloot sell dryrun\ax \aw(preview what would be sold - no changes)\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag} \ag/mac turboloot report\ax \aw(alias for \agsell dryrun\aw - same preview)\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag} \ag/mac turboloot bank\ax \aw(bank items marked \apBANK\aw)\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag} \ag/mac turboloot tribute\ax \aw(tribute items marked \ayTRIBUTE\aw)\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag} \ag/mac turboloot destroy\ax \aw(destroy items marked \arDESTROY\aw)\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag} \ag/mac turboloot unload\ax \aw(\apBANK\aw -> \ayTRIBUTE\aw -> \agSELL\aw -> \arDESTROY\aw)\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag} \ag/mac turboloot help\ax \aw(this list)\ax"

    /call HelpAnnounce "${helpMethod}" "${helpTag} \au==== \agINI \au====\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag} \at[Settings] \awcommon options:\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag}   \awannounceDefaultTo\ax \aw/\ax \awannounceBankSellTributeTo\ax \aw=\ax \agecho\ax|\age3bc\ax|\aysay\ax|\aggsay\ax|\ayrsay\ax|\ag\"t Name\"\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag}   \awannounceSkipTo\ax \aw=\ax \aysay\ax|\aggsay\ax|\ayrsay\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag}   \awsellWildcards\ax \aw=\ax \agON\ax|\arOFF\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag}   \awSellUnlistedStackable\ax \aw=\ax \arOFF\ax|\agON\ax \aw(sell unlisted stackables with vendor value)\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag}   \awsellUnlistedItems\ax \aw=\ax \arOFF\ax|\agON\ax \aw(sell ANY unlisted item with vendor value)\ax"

    /call HelpAnnounce "${helpMethod}" "${helpTag} \at[ItemLimits] \awcommon options:\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag}   \atALL\ax | \ay#\ax | \atKEEP\ax | \aoIGNORE\ax | \agSELL\ax | \apBANK\ax | \ayTRIBUTE\ax | \arDESTROY\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag}   \aw(ALL, KEEP, and # = keep in inv; only SELL/BANK/TRIBUTE/DESTROY are action keywords)\ax"
    /call HelpAnnounce "${helpMethod}" "${helpTag}   \ayTurboKey.mac:\ax \aw/mac TurboKey KEEP|SELL|IGNORE|BANK|TRIBUTE|ALL|DESTROY\aw (item on cursor)\ax"
/return

| ---------------------------------------------------------------------
| ANNOUNCE (logging wrapper)
| ---------------------------------------------------------------------
Sub Announce(string method, string msg)
    /declare methodTrim string local ${NormalizeAnnounceMethod[${method}]}
    /if (!${methodTrim.Length}) /varset methodTrim "echo"
    /declare mUpper string local ${methodTrim.Upper}
    /declare final string local ${msg}

    | echo/e3bc keep formatting
    /if (${mUpper.Equal[ECHO]} || ${mUpper.Equal[E3BC]}) {
        | /squelch hides the "command received:/e3bc ..." spam while still outputting the message.
        /docommand /squelch /${methodTrim} ${final}
        /return
    }

    | others get stripped formatting
    /declare formatted string local ${FormatMessage[${final},${methodTrim}]}
    /docommand /${methodTrim} ${formatted}
/return

Sub OnExit
    /call Cleanup
/return

| ---------------------------------------------------------------------
| DOOR HELP: open nearby doors (best-effort)
| ---------------------------------------------------------------------
Sub TryOpenNearbyDoor(int radius)
    /declare r int local ${radius}
    /if (${r} <= 0) /varset r 35

    /if (${SpawnCount[door radius ${r}]} == 0) /return FALSE

    /if (${showDebug}) /echo [turboLoot] Door nearby (within ${r}) - attempting to open...
    /doortarget
    /delay 2

    /if (${DoorTarget.ID}) {
        /click left door
        /delay 10
        /return TRUE
    }
/return FALSE

| ---------------------------------------------------------------------
| NAV TO ID WITH DOORS + NUDGES (NO MQ2MOVEUTILS)
| - Reissues /nav if it stops early
| - If stuck (no movement / no distance progress), tries to open doors and nudge
| Args:
|   targetID   = spawn ID to nav to
|   stopDist   = desired distance to stop
|   maxTicks   = max loop ticks (10 ticks ~= 1 second if delay 1 used)
| ---------------------------------------------------------------------
Sub NavToIDWithDoorsAndNudges(int targetID, float stopDist, int maxTicks)
    /declare tid int local ${targetID}
    /declare distGoal float local ${stopDist}
    /declare limit int local ${maxTicks}

    /declare navTicks int local 0
    /declare lastDist float local 999999
    /declare stuckCount int local 0
    /declare lastX float local ${Me.X}
    /declare lastY float local ${Me.Y}
    /declare nudgeFlip bool local FALSE

    | Start nav if possible
    /squelch /nav stop
    /if (${Navigation.PathExists[id ${tid}]}) {
        /nav id ${tid} distance=${distGoal}
    } else {
        | Still try nav id anyway (some builds will attempt even if PathExists lies)
        /nav id ${tid} distance=${distGoal}
    }

    :NavIDLoop
    /doevents
    /delay 1
    /varcalc navTicks ${navTicks} + 1

    | If target changed/lost, stop
    /if (!${Target.ID} || ${Target.ID} != ${tid}) {
        /squelch /nav stop
        /return
    }

    | Success
    /if (${Target.Distance} <= ${distGoal}) {
        /squelch /nav stop
        /return
    }

    | Track progress
    /if (${Math.Abs[${Target.Distance} - ${lastDist}]} < 0.5 && ${Math.Abs[${Me.X}-${lastX}]} < 0.5 && ${Math.Abs[${Me.Y}-${lastY}]} < 0.5) {
        /varcalc stuckCount ${stuckCount} + 1
    } else {
        /varset stuckCount 0
    }
    /varset lastDist ${Target.Distance}
    /varset lastX ${Me.X}
    /varset lastY ${Me.Y}

    | If nav stopped but we aren't close enough, restart it
    /if (!${Navigation.Active} && ${Target.Distance} > (${distGoal} + 2)) {
        /nav id ${tid} distance=${distGoal}
    }

    | If stuck for ~3 seconds, try door + nudge and restart nav
    /if (${stuckCount} >= 30) {
        /if (${showDebug}) /echo [turboLoot] Nav stuck (dist=${Target.Distance}) - trying door + nudge...
        /squelch /nav stop
        /call TryOpenNearbyDoor 40
        /face fast
        /delay 1

        | Nudge: forward + alternating strafe
        /keypress forward hold
        /delay 2
        /keypress forward

        /if (!${nudgeFlip}) {
            /keypress strafe_left hold
            /delay 2
            /keypress strafe_left
            /varset nudgeFlip TRUE
        } else {
            /keypress strafe_right hold
            /delay 2
            /keypress strafe_right
            /varset nudgeFlip FALSE
        }

        /varset stuckCount 0
        /nav id ${tid} distance=${distGoal}
    }

    | Periodically try opening doors while moving (every ~2s)
    /if (${Math.Calc[${navTicks}%20]} == 0) {
        /call TryOpenNearbyDoor 40
    }

    | Timeout
    /if (${navTicks} >= ${limit}) {
        /squelch /nav stop
        /return
    }

    /goto :NavIDLoop

| ---------------------------------------------------------------------
| NAV BACK TO GROUP LEADER
| Called after sell/bank/tribute/unload to return bot to leader
| Requires MQ2Nav. Skips if: not grouped, no leader, leader is self,
|   leader out of range/zone, or nav path doesn't exist.
| ---------------------------------------------------------------------
Sub NavBackToGroupLeader
    /if (!${Me.Grouped}) /return
    /if (${Me.Feigning}) /return
    /if (!${Group.Leader.ID}) /return
    /if (${Group.Leader.ID} == ${Me.ID}) /return
    /if (${Group.Leader.Zoning}) /return
    /if (!${Group.Leader.Present}) /return

    /declare navDist float local 30

    /if (${Group.Leader.Distance} <= ${navDist}) {
        /if (${showDebug}) /echo [turboLoot] NavBackToGroupLeader: Already within ${navDist} units of ${Group.Leader.Name}, skipping.
        /return
    }

    /call AnnounceBankSellProgress "${tlTag} \ayNavigating back to group leader: ${Group.Leader.Name}..."

    /target id ${Group.Leader.ID}
    /delay 5 ${Target.ID}
    /if (!${Target.ID}) /return

    /call NavToIDWithDoorsAndNudges ${Group.Leader.ID} ${navDist} 600

    /squelch /nav stop
    /squelch /target clear
    /if (${showDebug}) /echo [turboLoot] NavBackToGroupLeader: Done.
/return

| ---------------------------------------------------------------------
| LOAD WILDCARDS FROM INI [Wildcards] SECTION
| Reads prefixes from [Wildcards] and builds a pipe-delimited string
| for IsWildcardItem to check against.
| Format: |6:SPELL:||5:SONG:||8:TOME OF |
| ---------------------------------------------------------------------
Sub LoadWildcards
    /if (${Defined[wildcardPrefixes]}) /varset wildcardPrefixes ""

    | --- Built-in default prefixes (checked as keys in [Wildcards] section) ---
    | To add a new built-in default, add a line below following the same pattern.
    | Users can toggle these ON/OFF in their INI without editing this file.
    /declare wcVal string local
    /declare wcUpper string local
    /declare wcLen int local

    | Check: Spell:
    /varset wcVal ${Ini[${iniFile},Wildcards,Spell:]}
    /if (${wcVal.Length} && !${wcVal.Equal[NULL]} && !${wcVal.Equal[Null]} && !${wcVal.Equal[null]}) {
        /varset wcUpper ${wcVal.Upper.Replace[ ,]}
        /if (${wcUpper.Equal[ON]} || ${wcUpper.Equal[TRUE]} || ${wcUpper.Equal[YES]} || ${wcUpper.Equal[1]}) {
            /varset wildcardPrefixes "${wildcardPrefixes}|6:SPELL:"
            /if (${showDebug}) /echo [turboLoot] Wildcard loaded: "Spell:" (6 chars)
        }
    }

    | Check: Skill:
    /varset wcVal ${Ini[${iniFile},Wildcards,Skill:]}
    /if (${wcVal.Length} && !${wcVal.Equal[NULL]} && !${wcVal.Equal[Null]} && !${wcVal.Equal[null]}) {
        /varset wcUpper ${wcVal.Upper.Replace[ ,]}
        /if (${wcUpper.Equal[ON]} || ${wcUpper.Equal[TRUE]} || ${wcUpper.Equal[YES]} || ${wcUpper.Equal[1]}) {
            /varset wildcardPrefixes "${wildcardPrefixes}|6:SKILL:"
            /if (${showDebug}) /echo [turboLoot] Wildcard loaded: "Skill:" (6 chars)
        }
    }

    | Check: Song:
    /varset wcVal ${Ini[${iniFile},Wildcards,Song:]}
    /if (${wcVal.Length} && !${wcVal.Equal[NULL]} && !${wcVal.Equal[Null]} && !${wcVal.Equal[null]}) {
        /varset wcUpper ${wcVal.Upper.Replace[ ,]}
        /if (${wcUpper.Equal[ON]} || ${wcUpper.Equal[TRUE]} || ${wcUpper.Equal[YES]} || ${wcUpper.Equal[1]}) {
            /varset wildcardPrefixes "${wildcardPrefixes}|5:SONG:"
            /if (${showDebug}) /echo [turboLoot] Wildcard loaded: "Song:" (5 chars)
        }
    }

    | Check: Tome  (note trailing space - prevents matching "Tomestone" etc.)
    /varset wcVal ${Ini[${iniFile},Wildcards,Tome ]}
    /if (${wcVal.Length} && !${wcVal.Equal[NULL]} && !${wcVal.Equal[Null]} && !${wcVal.Equal[null]}) {
        /varset wcUpper ${wcVal.Upper.Replace[ ,]}
        /if (${wcUpper.Equal[ON]} || ${wcUpper.Equal[TRUE]} || ${wcUpper.Equal[YES]} || ${wcUpper.Equal[1]}) {
            /varset wildcardPrefixes "${wildcardPrefixes}|5:TOME "
            /if (${showDebug}) /echo [turboLoot] Wildcard loaded: "Tome " (5 chars)
        }
    }

    | Check: Tome of  (note trailing space)
    /varset wcVal ${Ini[${iniFile},Wildcards,Tome of ]}
    /if (${wcVal.Length} && !${wcVal.Equal[NULL]} && !${wcVal.Equal[Null]} && !${wcVal.Equal[null]}) {
        /varset wcUpper ${wcVal.Upper.Replace[ ,]}
        /if (${wcUpper.Equal[ON]} || ${wcUpper.Equal[TRUE]} || ${wcUpper.Equal[YES]} || ${wcUpper.Equal[1]}) {
            /varset wildcardPrefixes "${wildcardPrefixes}|8:TOME OF "
            /if (${showDebug}) /echo [turboLoot] Wildcard loaded: "Tome of " (8 chars)
        }
    }

    | --- User-added custom wildcards: Wildcard1 through Wildcard20 ---
    | In the INI, users set: Wildcard1=Rune of   (the VALUE is the prefix to match)
    /declare i int local
    /declare rawPrefix string local
    /for i 1 to 20
        /varset wcVal ${Ini[${iniFile},Wildcards,Wildcard${i}]}
        /if (${wcVal.Length} && !${wcVal.Equal[NULL]} && !${wcVal.Equal[Null]} && !${wcVal.Equal[null]}) {
            /varset rawPrefix ${StripIniComment[${wcVal}]}
            /if (${rawPrefix.Length}) {
                /varset wcLen ${rawPrefix.Length}
                /varset wildcardPrefixes "${wildcardPrefixes}|${wcLen}:${rawPrefix.Upper}"
                /if (${showDebug}) /echo [turboLoot] Wildcard loaded: "${rawPrefix}" (${wcLen} chars)
            }
        }
    /next i

    | Finalize
    /if (${wildcardPrefixes.Length}) {
        /varset wildcardPrefixes "${wildcardPrefixes}|"
        /if (${showDebug}) /echo [turboLoot] Wildcards active: ${wildcardPrefixes}
    } else /if (${showDebug}) {
        /echo [turboLoot] No wildcards loaded from [Wildcards] section.
    }
/return
